# GitHub Copilot Instructions - Project Instructions

> **‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT EDIT THIS FILE DIRECTLY**
>
> **Source:** `ai/rules/` ‚Äî All edits must be made there, not here.
>
> **Last synced:** December 25, 2025 at 18:56:50 PST ¬∑ Checksum: `4524808863ce`

## ü§ñ Instructions for AI Agents

**DO NOT modify this file.** Instead:

1. **To update instructions:** Edit the source files in `ai/rules/` directory
2. **After editing:** Run `npm run dev` or `npm run sync-agent-rules` to regenerate all agent files
3. **If you notice recurring issues:** Please proactively update the relevant file in `ai/rules/` to prevent the issue from happening again. Add new rules, clarify existing ones, or document patterns that help.

**Source files:** All `.md` files in `ai/rules/` directory.

**When to update the rules:**
- You keep making the same mistake ‚Üí Add a rule to prevent it
- A rule is unclear or incomplete ‚Üí Clarify it
- You discover a new best practice ‚Üí Document it
- The user corrects you on something ‚Üí Add it as a rule

---

---
trigger: always
description: Code quality standards for TypeScript, error handling, and maintainable code.
---

# Code Quality Standards

## TypeScript Best Practices

### Type Safety

**Avoid `any`** - It defeats the purpose of TypeScript:

```typescript
// ‚ùå Bad
function process(data: any) { ... }

// ‚úÖ Good - be specific
function process(data: UserData) { ... }

// ‚úÖ Good - use unknown if truly unknown, then narrow
function process(data: unknown) {
  if (isUserData(data)) { /* TypeScript knows it's UserData */ }
}
```

**Use strict null checks:**

```typescript
// ‚ùå Bad - might crash
function getName(user: User) {
  return user.profile.name; // What if profile is null?
}

// ‚úÖ Good - handle null cases
function getName(user: User) {
  return user.profile?.name ?? 'Anonymous';
}
```

### Type Definitions

**Define interfaces for all data shapes:**

```typescript
interface Event {
  id: string;
  name: string;
  date: Date;
  status: 'draft' | 'active' | 'completed';
}

function createEvent(data: Omit<Event, 'id'>): Event { ... }
function updateEvent(id: string, updates: Partial<Event>): void { ... }
```

**Prefer union types over enums for simple cases:**

```typescript
// ‚úÖ Preferred - simpler, better tree-shaking
type Status = 'loading' | 'success' | 'error';
```

## Error Handling

**Always handle promise rejections:**

```typescript
// ‚ùå Bad - unhandled rejection
async function fetchUser(id: string) {
  const user = await api.getUser(id);
  return user;
}

// ‚úÖ Good - explicit error handling
async function fetchUser(id: string): Promise<User | null> {
  try {
    return await api.getUser(id);
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
}
```

## Code Organization

### Keep Functions Small

```typescript
// ‚ùå Bad - does too much
function processOrder(order: Order) {
  // validate, calculate, discount, notify... 200 lines
}

// ‚úÖ Good - single responsibility
function processOrder(order: Order) {
  validateOrder(order);
  const totals = calculateTotals(order);
  const finalPrice = applyDiscounts(totals, order.coupons);
  updateInventory(order.items);
  notifyCustomer(order, finalPrice);
}
```

### Early Returns

```typescript
// ‚ùå Bad - deeply nested
function getDisplayName(user: User | null) {
  if (user) {
    if (user.profile) {
      return user.profile.displayName || user.email;
    }
    return user.email;
  }
  return 'Guest';
}

// ‚úÖ Good - flat with early returns
function getDisplayName(user: User | null) {
  if (!user) return 'Guest';
  if (!user.profile) return user.email;
  return user.profile.displayName || user.email;
}
```

### Extract Constants

```typescript
// ‚ùå Bad - magic numbers
if (cookies.length > 12) { ... }

// ‚úÖ Good - named constants
const MAX_COOKIES_PER_BAKER = 12;
if (cookies.length > MAX_COOKIES_PER_BAKER) { ... }
```

## Code Review Checklist

### General
- [ ] TypeScript compiles with no errors
- [ ] No `any` types (or justified with comment)
- [ ] Error cases are handled
- [ ] Functions are small and focused
- [ ] No console.log statements (except intentional logging)
- [ ] No commented-out code

### Testing
- [ ] Tests added for new functionality
- [ ] Storybook stories for new components

---

---
trigger: model_decision
description: Guidelines for Firebase deployments - when and how to deploy functions and security rules.
---

# Firebase Deployment Guidelines

## Deployment Safety

**Never deploy without verification.** Always:
1. Run `npm run verify` to ensure code quality
2. Test changes locally with emulators first
3. Confirm the deployment is intentional

## When to Deploy

### Cloud Functions (`functions/src/`)

Deploy after modifying:
- TypeScript files in `functions/src/`
- Function dependencies in `functions/package.json`
- TypeScript config in `functions/tsconfig.json`

**Command:** `npm run firebase:deploy:functions`

### Security Rules

Deploy after modifying:
- `firebase/firestore.rules` ‚Üí `npm run firebase:deploy:firestore`
- `firebase/storage.rules` ‚Üí `npm run firebase:deploy:storage`
- Both ‚Üí `npm run firebase:deploy:rules`

## When NOT to Deploy

Do not trigger deployment for:
- Documentation changes (`.md` files)
- Frontend-only changes (`src/` except functions)
- Test file changes (unless they reveal function bugs)
- Storybook or story changes

## Pre-Deployment Checklist

### For Functions:
- [ ] TypeScript compiles without errors: `npm run build --prefix functions`
- [ ] Related unit tests pass
- [ ] Tested against local emulators
- [ ] Changes reviewed for security implications

### For Security Rules:
- [ ] Rules syntax is valid (no `if`, `const`, `let`)
- [ ] Tested read/write scenarios in emulator
- [ ] No unintended permission changes

## Firestore Rules Syntax

Firestore rules have unique syntax requirements:

```javascript
// ‚ùå WRONG - if statements not supported
if (request.auth != null) {
  allow read;
}

// ‚úÖ CORRECT - use ternary or boolean expressions
allow read: if request.auth != null;

// ‚ùå WRONG - no variable declarations
let userId = request.auth.uid;

// ‚úÖ CORRECT - inline expressions
allow write: if request.auth.uid == resource.data.ownerId;

// ‚úÖ Use && and || for complex conditions
allow update: if request.auth != null 
              && request.auth.uid == resource.data.ownerId
              && request.resource.data.status in ['draft', 'published'];
```

## Available Scripts

| Script | Purpose |
|--------|---------|
| `npm run firebase:deploy:functions` | Build and deploy Cloud Functions |
| `npm run firebase:deploy:firestore` | Deploy Firestore security rules |
| `npm run firebase:deploy:storage` | Deploy Storage security rules |
| `npm run firebase:deploy:rules` | Deploy both Firestore and Storage rules |

## Troubleshooting Deployments

### Function Deployment Fails

1. Check TypeScript compilation: `npm run build --prefix functions`
2. Look for missing dependencies
3. Check for runtime vs build-time errors
4. Verify Firebase project configuration

### Rules Deployment Fails

1. Check for syntax errors (no `if`, `const`, `let`)
2. Validate rule structure
3. Test in Firebase console rules playground

## Post-Deployment

After successful deployment:
1. Verify the deployment in Firebase Console
2. Test critical functionality in production
3. Monitor for errors in Firebase Functions logs

---

---
trigger: model_decision
description: Firebase/Firestore coding patterns and best practices.
---

# Firebase Patterns

## Firestore Queries

**Always handle loading and error states:**

```typescript
function useEvent(eventId: string) {
  const [event, setEvent] = useState<Event | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const unsubscribe = onSnapshot(
      doc(db, 'events', eventId),
      (snapshot) => {
        setEvent(snapshot.exists() ? { id: snapshot.id, ...snapshot.data() } as Event : null);
        setIsLoading(false);
      },
      (err) => {
        setError(err);
        setIsLoading(false);
      }
    );
    return unsubscribe;
  }, [eventId]);

  return { event, isLoading, error };
}
```

## Real-time Subscriptions

**Always clean up listeners:**

```typescript
useEffect(() => {
  const unsubscribe = onSnapshot(collection(db, 'events'), (snapshot) => {
    // handle data
  });
  
  return () => unsubscribe(); // Clean up!
}, []);
```

## Batched Writes

**Use batches for multiple operations:**

```typescript
async function updateEventWithBakers(eventId: string, bakerIds: string[]) {
  const batch = writeBatch(db);
  
  batch.update(doc(db, 'events', eventId), { 
    updatedAt: serverTimestamp() 
  });
  
  bakerIds.forEach((bakerId) => {
    batch.update(doc(db, 'bakers', bakerId), { eventId });
  });
  
  await batch.commit();
}
```

## Timestamps

**Always use server timestamps:**

```typescript
import { serverTimestamp } from 'firebase/firestore';

await addDoc(collection(db, 'events'), {
  name: 'Cookie Contest',
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp(),
});
```

## Firebase in Hooks Only

**Keep Firebase out of components:**

```typescript
// ‚ùå Bad - Firebase in component
function EventList() {
  useEffect(() => {
    const q = query(collection(db, 'events'));
    // Firebase logic in component...
  }, []);
}

// ‚úÖ Good - Firebase in custom hook
function EventList() {
  const { events, isLoading } = useEvents();
  // Component only handles rendering
}
```

## Error Handling

**Provide user-friendly error messages:**

```typescript
async function createEvent(data: EventData) {
  try {
    await addDoc(collection(db, 'events'), data);
  } catch (error) {
    if (error.code === 'permission-denied') {
      throw new Error('You do not have permission to create events');
    }
    if (error.code === 'unavailable') {
      throw new Error('Unable to connect. Check your internet connection');
    }
    throw new Error('Failed to create event. Please try again');
  }
}
```

## Security Considerations

**Never trust client-side data - let security rules validate:**

```typescript
// In firestore.rules, validate ownership:
// allow create: if request.auth.uid == request.resource.data.createdBy;
```

## Firebase Checklist

- [ ] All listeners cleaned up on unmount
- [ ] Server timestamps used for dates
- [ ] Error messages are user-friendly
- [ ] Batch writes used for multiple operations
- [ ] Firebase logic lives in hooks, not components

---

---
trigger: always
description: Core project guidelines, architecture, and development standards.
---

# Project Guidelines & Standards

## Architecture Principles

### Separation of Concerns
- **UI (components/)**: Presentational only. Receive data via props.
- **Logic (lib/hooks/)**: Data fetching, state management, side effects.
- **Utils (lib/)**: Pure functions (formatting, calculations).
- **No Firebase in UI**: Components must NEVER import Firebase directly.

### Project Structure
```
src/
‚îú‚îÄ‚îÄ components/       # Atoms, Molecules, Organisms
‚îú‚îÄ‚îÄ pages/            # Route-level components
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ hooks/        # Custom React hooks (useAuth, useEvent)
‚îÇ   ‚îú‚îÄ‚îÄ stores/       # Zustand stores
‚îÇ   ‚îî‚îÄ‚îÄ firebase.ts   # Firebase init
```

## Code Standards

### Naming Conventions
- **Components**: PascalCase (`CookieViewer.tsx`)
- **Hooks**: camelCase + use (`useAuth.ts`)
- **Utilities**: camelCase (`formatDate.ts`)
- **Constants**: SCREAMING_SNAKE_CASE (`MAX_ITEMS`)

### Files
- **One component per file**.
- **Co-locate**: Styles, stories, and tests next to the component.
- **Index exports**: Use `index.ts` for clean directory imports.

## Development Workflow
1. **Understand** the code patterns and finding similar implementations.
2. **Storybook First**: Build UI components in isolation before integration.
3. **Verify**: Always run `npm run verify` before committing.

## Universal Requirements
- **Accessibility**: All UI must be accessible (semantic HTML, ARIA, keyboard nav).
- **Responsiveness**: Mobile-first design.
- **Error Handling**: Graceful degradation, user-friendly errors.

---

---
trigger: model_decision
description: React patterns including hooks, component design, and performance optimization.
---

# React Patterns & Best Practices

## Core Principles
1. **Unidirectional Data Flow**: Data flows down, actions flow up.
2. **Composition over Inheritance**: Use `children` prop and composition to build complex UIs.
3. **Immutable State**: Never mutate state directly; use setters.
4. **Separation of Concerns**: Logic in hooks, UI in components.

## Hooks Rules
1. **Top Level Only**: Never call hooks in loops, conditions, or nested functions.
2. **React Functions Only**: Call from components or custom hooks.
3. **Dependencies**: `useEffect`, `useCallback`, `useMemo` dependency arrays must be exhaustive.
4. **Naming**: Custom hooks must start with `use`.

### Common Hooks Usage
- **useState**: For local UI state. Use functional updates `setCount(c => c + 1)` for state dependent on previous value.
- **useEffect**: For side effects (subscriptions, DOM). **Always return a cleanup function**.
- **useContext**: To avoid prop drilling global data (auth, theme).
- **useMemo/useCallback**: Memoize expensive calculations or functions passed to memoized children.

## Component Patterns

### Container/Presenter
Separate data fetching/logic from rendering.
```tsx
// Container: Handles logic & data
const UserProfile = ({ id }) => {
  const { user, loading } = useUser(id);
  if (loading) return <Spinner />;
  return <UserProfileView user={user} />;
};

// Presenter: Pure UI
const UserProfileView = ({ user }) => <h1>{user.name}</h1>;
```

### Compound Components
For components that work together (e.g., Tabs, Card).
```tsx
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
</Card>
```

## Performance Optimization

### Rendering
- **Minimize State**: Derive values during render where possible.
- **React.memo**: Wrap pure functional components to prevent re-renders when props haven't changed.
- **Stable Props**: Use `useCallback` for event handlers passed to child components.
- **Virtualization**: Use `react-window` for long lists.

### Code Splitting
- **Lazy Loading**: Use `React.lazy` and `Suspense` for route-based splitting.
- **Dynamic Imports**: Import heavy libraries on demand.

## Anti-Patterns to Avoid
- **Prop Drilling**: Passing props through >2 layers (use Composition or Context).
- **Large Components**: Split components >150 lines.
- **Logic in JSX**: Move complex conditionals/maps to variables or sub-components.
- **Derived State in State**: Don't store `fullName` if you have `firstName` and `lastName`.

## React Checklist
- [ ] Hooks follow strict ordering and dependency rules
- [ ] Components are small (<150 lines) and focused
- [ ] State is lifted to the lowest common ancestor
- [ ] Expensive calculations are memoized
- [ ] No direct Firebase calls in components (use hooks)

---

---
trigger: always
description: TDD workflow and testing strategy - tests before code, verification requirements.
---

# Testing Strategy & TDD Workflow

## 1. TDD Workflow (Required)
**Follow strict Test-Driven Development:**

1. **Propose Test Cases**: Before coding, outline what you will test.
2. **Clarify**: Ask user if requirements are ambiguous.
3. **Write Tests**: Create failing tests defining expected behavior.
4. **Red**: Confirm tests fail.
5. **Green**: Write minimum code to pass.
6. **Refactor**: improve code while keeping tests passing.

### Test Plan Template
Use this to propose tests to the user:
```markdown
## Proposed Test Cases for [Feature]
### Happy Path
- [ ] [Description]
### Edge/Error Cases
- [ ] Empty/Null inputs
- [ ] Network failures / Permission denied
```

## 2. Testing Pyramid & Tools

| Layer | Tool | Scope | Command |
|-------|------|-------|---------|
| **E2E** | Playwright | Critical user flows | `npm run test:e2e` |
| **Integration** | Vitest + Emulators | Firestore rules, Functions | `npm run test:integration` |
| **Component** | Storybook | UI interactions (`play` functions) | `npm run test-storybook` |
| **Unit** | Vitest | Logic, Hooks, Utils | `npm run test` |
| **Static** | ESLint/TSC | Code quality, Types | `npm run verify` |

## 3. What to Test
- **Unit**: Complex logic, custom hooks, utils. Mock dependencies with `vi.mock()`.
- **Component**: User interactions (clicks, forms). Don't test style details.
- **Integration**: Security rules, backend triggers (use Emulators).
- **Skip**: Simple presentational components, 3rd party config.

## 4. Vitest Best Practices

### Mocking
```typescript
import { vi, type Mock } from 'vitest';

vi.mock('../lib/firestore');
const mockedFn = someFn as Mock;
mockedFn.mockResolvedValue({ id: '123' });
```

### Cleanup
```typescript
afterEach(() => {
  vi.clearAllMocks();
});
```

## 5. Verification
Run `npm run verify` before *every* commit. It runs lint, types, tests, and build checks.

### Debugging
- Check error message -> Check recent changes -> Run in isolation.
- Use `npm run test:watch` for interactive development.
- Ensure Emulators are running for integration tests (`npm run emulators:start`).

---

---
trigger: model_decision
description: Standards for building UI components with React, TypeScript, and Storybook.
---

# UI Component Standards

## Design Principles
1. **Single Responsibility**: One thing well. Split if >150 lines.
2. **Props-Based**: No internal data fetching. Use callbacks for actions.
3. **Type Safety**: strict interfaces for Props. Export them.

```tsx
interface ButtonProps {
  variant: 'primary' | 'secondary';
  onClick?: () => void;
  children: React.ReactNode;
}
```

## Storybook Development
**Workflow:**
1. **Build in Storybook**: Don't integrate until the component works in isolation.
2. **Variations**: Create stories for Primary, Disabled, Loading, Error, Empty.
3. **Interaction**: Use `play` functions to test behavior.
4. **Accessibility**: Check the a11y addon tab.

**Story Example:**
```tsx
const meta: Meta<typeof Button> = { component: Button };
export default meta;

export const Primary: Story = { args: { variant: 'primary' } };
export const Interaction: Story = {
  play: async ({ canvas }) => {
    await canvas.getByRole('button').click();
  }
};
```

## Styling (CSS Modules)
- Use `.module.css` files.
- CamelCase class names: `styles.buttonPrimary`.
- Scope styles strictly to the component.

## Accessibility Checklist
- [ ] Semantic HTML (`<button>` not `<div>`)
- [ ] Visible focus states
- [ ] Keyboard navigation support
- [ ] Color contrast (WCAG AA)
- [ ] Appropriate ARIA labels where needed

---

---
trigger: model_decision
description: Zustand state management patterns and best practices.
---

# Zustand Patterns

## Store Structure

**Keep stores focused and small:**

```typescript
interface AuthStore {
  user: User | null;
  isLoading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  isLoading: true,
  signIn: async (email, password) => {
    set({ isLoading: true });
    const user = await authService.signIn(email, password);
    set({ user, isLoading: false });
  },
  signOut: async () => {
    await authService.signOut();
    set({ user: null });
  },
}));
```

## Selectors

**Use selectors to prevent unnecessary re-renders:**

```typescript
// ‚ùå Bad - component re-renders on ANY store change
function UserProfile() {
  const store = useAuthStore();
  return <div>{store.user?.name}</div>;
}

// ‚úÖ Good - only re-renders when user changes
function UserProfile() {
  const user = useAuthStore((state) => state.user);
  return <div>{user?.name}</div>;
}

// ‚úÖ Good - select multiple values
function AuthStatus() {
  const { user, isLoading } = useAuthStore(
    (state) => ({ user: state.user, isLoading: state.isLoading })
  );
}
```

## Async Actions

**Handle loading and error states:**

```typescript
interface EventStore {
  events: Event[];
  isLoading: boolean;
  error: string | null;
  fetchEvents: () => Promise<void>;
}

export const useEventStore = create<EventStore>((set) => ({
  events: [],
  isLoading: false,
  error: null,
  fetchEvents: async () => {
    set({ isLoading: true, error: null });
    try {
      const events = await eventService.getAll();
      set({ events, isLoading: false });
    } catch (error) {
      set({ error: 'Failed to load events', isLoading: false });
    }
  },
}));
```

## Store Organization

```
src/lib/stores/
‚îú‚îÄ‚îÄ useAuthStore.ts      # Authentication state
‚îú‚îÄ‚îÄ useEventStore.ts     # Event data
‚îú‚îÄ‚îÄ useBakerStore.ts     # Baker data
‚îî‚îÄ‚îÄ useUIStore.ts        # UI state (modals, toasts)
```

## When to Use Zustand vs Local State

| Use Case | Solution |
|----------|----------|
| Form input values | `useState` |
| Modal open/closed | `useState` |
| Current user | Zustand |
| Shared data across routes | Zustand |
| Server cache | Zustand or React Query |

## Zustand Checklist

- [ ] Stores are focused (single responsibility)
- [ ] Selectors used to prevent unnecessary re-renders
- [ ] Loading and error states handled in async actions
- [ ] Store actions handle their own errors

---

