# Windsurf Rules - Project Instructions

> **‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT EDIT THIS FILE DIRECTLY**
>
> **Source:** `ai/rules/` ‚Äî All edits must be made there, not here.
>
> **Last synced:** February 06, 2026 at 10:33:59 UTC ¬∑ Checksum: `55561eaac6f1`

## ü§ñ Instructions for AI Agents

**DO NOT modify this file.** Instead:

1. **To update instructions:** Edit the source files in `ai/rules/` directory
2. **After editing:** Run `npm run dev` or `npm run sync-agent-rules` to regenerate all agent files
3. **If you notice recurring issues:** Please proactively update the relevant file in `ai/rules/` to prevent the issue from happening again. Add new rules, clarify existing ones, or document patterns that help.

**Source files:** All `.md` files in `ai/rules/` directory.

**When to update the rules:**
- You keep making the same mistake ‚Üí Add a rule to prevent it
- A rule is unclear or incomplete ‚Üí Clarify it
- You discover a new best practice ‚Üí Document it
- The user corrects you on something ‚Üí Add it as a rule

---

---
trigger: always
description: Code quality standards for TypeScript, error handling, and maintainable code.
---

# Code Quality Standards

## TypeScript Best Practices

### Type Safety

**Avoid `any`** - It defeats the purpose of TypeScript:

```typescript
// ‚ùå Bad
function process(data: any) { ... }

// ‚úÖ Good - be specific
function process(data: UserData) { ... }

// ‚úÖ Good - use unknown if truly unknown, then narrow
function process(data: unknown) {
  if (isUserData(data)) { /* TypeScript knows it's UserData */ }
}
```

**Use strict null checks:**

```typescript
// ‚ùå Bad - might crash
function getName(user: User) {
  return user.profile.name; // What if profile is null?
}

// ‚úÖ Good - handle null cases
function getName(user: User) {
  return user.profile?.name ?? 'Anonymous';
}
```

### Type Definitions

**Define interfaces for all data shapes:**

```typescript
interface Event {
  id: string;
  name: string;
  date: Date;
  status: 'draft' | 'active' | 'completed';
}

function createEvent(data: Omit<Event, 'id'>): Event { ... }
function updateEvent(id: string, updates: Partial<Event>): void { ... }
```

**Prefer union types over enums for simple cases:**

```typescript
// ‚úÖ Preferred - simpler, better tree-shaking
type Status = 'loading' | 'success' | 'error';
```

## Error Handling

**Always handle promise rejections:**

```typescript
// ‚ùå Bad - unhandled rejection
async function fetchUser(id: string) {
  const user = await api.getUser(id);
  return user;
}

// ‚úÖ Good - explicit error handling
async function fetchUser(id: string): Promise<User | null> {
  try {
    return await api.getUser(id);
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
}
```

## Code Organization

### Keep Functions Small

```typescript
// ‚ùå Bad - does too much
function processOrder(order: Order) {
  // validate, calculate, discount, notify... 200 lines
}

// ‚úÖ Good - single responsibility
function processOrder(order: Order) {
  validateOrder(order);
  const totals = calculateTotals(order);
  const finalPrice = applyDiscounts(totals, order.coupons);
  updateInventory(order.items);
  notifyCustomer(order, finalPrice);
}
```

### Early Returns

```typescript
// ‚ùå Bad - deeply nested
function getDisplayName(user: User | null) {
  if (user) {
    if (user.profile) {
      return user.profile.displayName || user.email;
    }
    return user.email;
  }
  return 'Guest';
}

// ‚úÖ Good - flat with early returns
function getDisplayName(user: User | null) {
  if (!user) return 'Guest';
  if (!user.profile) return user.email;
  return user.profile.displayName || user.email;
}
```

### Extract Constants

```typescript
// ‚ùå Bad - magic numbers
if (cookies.length > 12) { ... }

// ‚úÖ Good - named constants
const MAX_COOKIES_PER_BAKER = 12;
if (cookies.length > MAX_COOKIES_PER_BAKER) { ... }
```

## Code Review Checklist

### General
- [ ] TypeScript compiles with no errors
- [ ] No `any` types (or justified with comment)
- [ ] Error cases are handled
- [ ] Functions are small and focused
- [ ] No console.log statements (except intentional logging)
- [ ] No commented-out code

### Testing
- [ ] Tests added for new functionality
- [ ] Storybook stories for new components

---

---
trigger: model_decision
description: Guidelines for Firebase deployments - when and how to deploy functions and security rules.
---

# Firebase Deployment Guidelines

## Deployment Safety

**Never deploy without verification.** Always:
1. Run `npm run verify` to ensure code quality
2. Test changes locally first
3. Confirm the deployment is intentional

## When to Deploy

### Cloud Functions (`functions/src/`)

Deploy after modifying:
- TypeScript files in `functions/src/`
- Function dependencies in `functions/package.json`
- TypeScript config in `functions/tsconfig.json`

**Command:** `npm run firebase:deploy:functions`

### Security Rules

Deploy after modifying:
- `firebase/firestore.rules` ‚Üí `npm run firebase:deploy:firestore`
- `firebase/storage.rules` ‚Üí `npm run firebase:deploy:storage`
- Both ‚Üí `npm run firebase:deploy:rules`

## When NOT to Deploy

Do not trigger deployment for:
- Documentation changes (`.md` files)
- Frontend-only changes (`src/` except functions)
- Test file changes (unless they reveal function bugs)
- Storybook or story changes

## Pre-Deployment Checklist

### For Functions:
- [ ] TypeScript compiles without errors: `npm run build --prefix functions`
- [ ] Related unit tests pass
- [ ] Tested against local dev environment
- [ ] Changes reviewed for security implications

### For Security Rules:
- [ ] Rules syntax is valid (no `if`, `const`, `let`)
- [ ] Tested read/write scenarios
- [ ] No unintended permission changes

## Firestore Rules Syntax

Firestore rules have unique syntax requirements:

```javascript
// ‚ùå WRONG - if statements not supported
if (request.auth != null) {
  allow read;
}

// ‚úÖ CORRECT - use ternary or boolean expressions
allow read: if request.auth != null;

// ‚ùå WRONG - no variable declarations
let userId = request.auth.uid;

// ‚úÖ CORRECT - inline expressions
allow write: if request.auth.uid == resource.data.ownerId;

// ‚úÖ Use && and || for complex conditions
allow update: if request.auth != null 
              && request.auth.uid == resource.data.ownerId
              && request.resource.data.status in ['draft', 'published'];
```

## Available Scripts

| Script | Purpose |
|--------|---------|
| `npm run firebase:deploy:functions` | Build and deploy Cloud Functions |
| `npm run firebase:deploy:firestore` | Deploy Firestore security rules |
| `npm run firebase:deploy:storage` | Deploy Storage security rules |
| `npm run firebase:deploy:rules` | Deploy both Firestore and Storage rules |

## Troubleshooting Deployments

### Function Deployment Fails

1. Check TypeScript compilation: `npm run build --prefix functions`
2. Look for missing dependencies
3. Check for runtime vs build-time errors
4. Verify Firebase project configuration

### Rules Deployment Fails

1. Check for syntax errors (no `if`, `const`, `let`)
2. Validate rule structure
3. Test in Firebase console rules playground

## Post-Deployment

After successful deployment:
1. Verify the deployment in Firebase Console
2. Test critical functionality in production
3. Monitor for errors in Firebase Functions logs

---

---
trigger: model_decision
description: Firebase/Firestore coding patterns and best practices.
---

# Firebase Patterns

## Firestore Queries

**Always handle loading and error states:**

```typescript
function useEvent(eventId: string) {
  const [event, setEvent] = useState<Event | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const unsubscribe = onSnapshot(
      doc(db, 'events', eventId),
      (snapshot) => {
        setEvent(snapshot.exists() ? { id: snapshot.id, ...snapshot.data() } as Event : null);
        setIsLoading(false);
      },
      (err) => {
        setError(err);
        setIsLoading(false);
      }
    );
    return unsubscribe;
  }, [eventId]);

  return { event, isLoading, error };
}
```

## Real-time Subscriptions

**Always clean up listeners:**

```typescript
useEffect(() => {
  const unsubscribe = onSnapshot(collection(db, 'events'), (snapshot) => {
    // handle data
  });
  
  return () => unsubscribe(); // Clean up!
}, []);
```

## Batched Writes

**Use batches for multiple operations:**

```typescript
async function updateEventWithBakers(eventId: string, bakerIds: string[]) {
  const batch = writeBatch(db);
  
  batch.update(doc(db, 'events', eventId), { 
    updatedAt: serverTimestamp() 
  });
  
  bakerIds.forEach((bakerId) => {
    batch.update(doc(db, 'bakers', bakerId), { eventId });
  });
  
  await batch.commit();
}
```

## Timestamps

**Always use server timestamps:**

```typescript
import { serverTimestamp } from 'firebase/firestore';

await addDoc(collection(db, 'events'), {
  name: 'Cookie Contest',
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp(),
});
```

## Firebase in Hooks Only

**Keep Firebase out of components:**

```typescript
// ‚ùå Bad - Firebase in component
function EventList() {
  useEffect(() => {
    const q = query(collection(db, 'events'));
    // Firebase logic in component...
  }, []);
}

// ‚úÖ Good - Firebase in custom hook
function EventList() {
  const { events, isLoading } = useEvents();
  // Component only handles rendering
}
```

## Error Handling

**Provide user-friendly error messages:**

```typescript
async function createEvent(data: EventData) {
  try {
    await addDoc(collection(db, 'events'), data);
  } catch (error) {
    if (error.code === 'permission-denied') {
      throw new Error('You do not have permission to create events');
    }
    if (error.code === 'unavailable') {
      throw new Error('Unable to connect. Check your internet connection');
    }
    throw new Error('Failed to create event. Please try again');
  }
}
```

## Security Considerations

**Never trust client-side data - let security rules validate:**

```typescript
// In firestore.rules, validate ownership:
// allow create: if request.auth.uid == request.resource.data.createdBy;
```

## Firebase Checklist

- [ ] All listeners cleaned up on unmount
- [ ] Server timestamps used for dates
- [ ] Error messages are user-friendly
- [ ] Batch writes used for multiple operations
- [ ] Firebase logic lives in hooks, not components

---

---
trigger: always
description: Core project guidelines, architecture, and development standards.
---

# Project Guidelines & Standards

## Tech Stack (Enforced)
- **Framework**: React 19 (Do not use legacy React patterns).
- **Styling**: Tailwind CSS 4 (Use new utility-first engine).
- **Runtime**: Node.js 20+.
- **Backend**: Firebase 12 (Firestore, Auth, Storage, Functions).
- **Language**: TypeScript 5.9+.

## Architecture Principles

### Separation of Concerns
- **UI (components/)**: Presentational only. Receive data via props.
- **Logic (lib/hooks/)**: Data fetching, state management, side effects.
- **Utils (lib/)**: Pure functions (formatting, calculations).
- **No Firebase in UI**: Components must NEVER import Firebase directly.

### Project Structure
```
src/
‚îú‚îÄ‚îÄ components/       # Atoms, Molecules, Organisms
‚îú‚îÄ‚îÄ pages/            # Route-level components
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ hooks/        # Custom React hooks (useAuth, useEvent)
‚îÇ   ‚îú‚îÄ‚îÄ stores/       # Zustand stores
‚îÇ   ‚îî‚îÄ‚îÄ firebase.ts   # Firebase init
```

## Code Standards

### Naming Conventions
- **Components**: PascalCase (`CookieViewer.tsx`)
- **Hooks**: camelCase + use (`useAuth.ts`)
- **Utilities**: camelCase (`formatDate.ts`)
- **Constants**: SCREAMING_SNAKE_CASE (`MAX_ITEMS`)

### Files
- **One component per file**.
- **Co-locate**: Styles, stories, and tests next to the component.
- **Index exports**: Use `index.ts` for clean directory imports.

## Development Workflow
1. **Understand** the code patterns and finding similar implementations.
2. **Storybook First**: Build UI components in isolation before integration.
3. **Verify**: Always run `npm run verify` before committing.

## Universal Requirements
- **Accessibility**: All UI must be accessible (semantic HTML, ARIA, keyboard nav).
- **Responsiveness**: Mobile-first design. All UIs must be fully functional and aesthetic on mobile devices, while adapting gracefully to larger screens.
- **Error Handling**: Graceful degradation, user-friendly errors.

## Design Philosophy
- **Modern & Premium**: Use rich aesthetics, glassmorphism, smooth animations, and curated color palettes.
- **Mobile-First**: Design for touch targets and small screens first.

## UX Standards
1.  **Optimistic UI Required**: All user actions (likes, edits, deletes) must update the UI *instantly*. The network request happens in the background.
2.  **No Jarring Reloads**: 
    - **NEVER** trigger a full-page loading spinner for a small action.
    - **NEVER** unmount a component just to show a loader state during an update.
    - Only use full-page loaders for initial route navigation.
3.  **Seamless Persistence**: Data saving should be transparent (auto-save), not requiring manual "Save" buttons unless necessary for large forms.

---

---
trigger: model_decision
description: React patterns including hooks, component design, and performance optimization.
---

# React Patterns & Best Practices

## Core Principles
1. **Unidirectional Data Flow**: Data flows down, actions flow up.
2. **Composition over Inheritance**: Use `children` prop and composition to build complex UIs.
3. **Immutable State**: Never mutate state directly; use setters.
4. **Separation of Concerns**: Logic in hooks, UI in components.

## Hooks Rules
1. **Top Level Only**: Never call hooks in loops, conditions, or nested functions.
2. **React Functions Only**: Call from components or custom hooks.
3. **Dependencies**: `useEffect`, `useCallback`, `useMemo` dependency arrays must be exhaustive.
4. **Naming**: Custom hooks must start with `use`.

### Common Hooks Usage
- **useState**: For local UI state. Use functional updates `setCount(c => c + 1)` for state dependent on previous value.
- **useEffect**: For side effects (subscriptions, DOM). **Always return a cleanup function**.
- **useContext**: To avoid prop drilling global data (auth, theme).
- **useMemo/useCallback**: Memoize expensive calculations or functions passed to memoized children.

## Component Patterns

### Container/Presenter
Separate data fetching/logic from rendering.
```tsx
// Container: Handles logic & data
const UserProfile = ({ id }) => {
  const { user, isLoading } = useUser(id);
  // ‚úÖ Good - Pass loading state down, don't unmount the view
  return <UserProfileView user={user} isLoading={isLoading} />;
};

// Presenter: Pure UI
const UserProfileView = ({ user, isLoading }) => {
  if (isLoading && !user) return <SkeletonLoader />; // Only full loader on initial mount
  return (
    <div className={isLoading ? 'opacity-50' : ''}>
      <h1>{user?.name}</h1>
    </div>
  );
};
```

### Seamless UX Principles
1.  **Preserve Context**: Never hide content the user is interacting with during a background update.
2.  **Inline Feedback**: Use button loading states or small indicators instead of full-page spinners for actions.
3.  **Skeleton Loading**: Use skeletons instead of spinners for initial loads to reduce layout shift.

### Compound Components
For components that work together (e.g., Tabs, Card).
```tsx
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
</Card>
```

## Performance Optimization

### Rendering
- **Minimize State**: Derive values during render where possible.
- **React.memo**: Wrap pure functional components to prevent re-renders when props haven't changed.
- **Stable Props**: Use `useCallback` for event handlers passed to child components.
- **Virtualization**: Use `react-window` for long lists.

### Code Splitting
- **Lazy Loading**: Use `React.lazy` and `Suspense` for route-based splitting.
- **Dynamic Imports**: Import heavy libraries on demand.

## Anti-Patterns to Avoid
- **Prop Drilling**: Passing props through >2 layers (use Composition or Context).
- **Large Components**: Split components >150 lines.
- **Logic in JSX**: Move complex conditionals/maps to variables or sub-components.
- **Derived State in State**: Don't store `fullName` if you have `firstName` and `lastName`.

## React Checklist
- [ ] Hooks follow strict ordering and dependency rules
- [ ] Components are small (<150 lines) and focused
- [ ] State is lifted to the lowest common ancestor
- [ ] Expensive calculations are memoized
- [ ] No direct Firebase calls in components (use hooks)

---

---
trigger: always
description: Best practices for using Shadcn/UI components, styling with Tailwind, and ensuring consistent design.
---

# Shadcn/UI & Design System

## Core Philosophy
We use **Shadcn/UI** (Radix UI + Tailwind) as our foundation. The goal is to build a **premium, accessible, and consistent** application.

1.  **Prefer Composition**: Use existing components (`<Button>`, `<Card>`) before writing custom `<div className="...">`.
2.  **Accessibility First**: Shadcn components are accessible by default. Preserve this (e.g., proper labels, focus states).
3.  **Consistent Polish**: Use the defined variants (`default`, `secondary`, `destructive`, `ghost`) instead of random colors.

## Usage Guidelines

### 1. Imports
**Always import from `@/components/ui/...`**

```tsx
// ‚úÖ Correct
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardContent } from "@/components/ui/card";

// ‚ùå Incorrect - do not import from raw Radix or local relative paths if generic
import * as RadixPop from "@radix-ui/react-popover";
import { Button } from "../../components/ui/button";
```

### 2. Class Merging (`cn`)
**Always use `cn()`** to merge classes when creating manageable components or passing `className` props.

```tsx
import { cn } from "@/lib/utils";

export function CustomCard({ className, children }: { className?: string, children: React.ReactNode }) {
  // Allows the parent to override 'bg-white' with 'bg-gray-100' safely
  return <div className={cn("bg-white p-4 rounded-lg", className)}>{children}</div>;
}
```

### 3. Component Library
The following components are available in `src/components/ui/`. **Use them!**

| Component | Usage |
| :--- | :--- |
| **Button** | Primary actions. Use `variant="ghost"` for icon-only buttons. |
| **Input** | Text inputs. |
| **Label** | Form labels. Always associate with inputs. |
| **Card** | Content containers. Use `CardHeader`, `CardTitle`, `CardContent`. |
| **Tabs** | Switch between views (e.g., Admin Dashboard). |
| **Dialog** | Modals. Use `DialogTrigger` and `DialogContent`. |
| **Select** | Dropdowns. Prefer over native `<select>`. |
| **Toast** | Notifications via `useToast`. |

### 4. Icons
**Use `lucide-react`** for all icons.
- Import standard named icons (e.g., `Trash2`, `Plus`, `Settings`).
- Size them consistently (usually `w-4 h-4` or `w-5 h-5`).

```tsx
import { Plus } from "lucide-react";
<Button><Plus className="w-4 h-4 mr-2" /> Add Item</Button>
```

## Anti-Patterns
- **‚ùå Arbitrary Colors**: Avoid `bg-[#123456]`. Use `bg-primary`, `bg-muted`, etc.
- **‚ùå Reinventing the Wheel**: Don't build a custom modal using a standard div; use `<Dialog>`.
- **‚ùå Inconsistent Spacing**: Use standard Tailwind spacings (`gap-2`, `p-4`, `p-6`).

## Checklist for UI Changes
- [ ] Did I use a Shadcn component if it exists?
- [ ] Are interactions accessible (keyboard navigable)?
- [ ] Did I use `lucide-react` icons?
- [ ] Did I handle mobile responsiveness?

---

---
trigger: model_decision
description: Best practices for using Tailwind CSS - utility-first, responsiveness, and class merging.
---

# Tailwind CSS Best Practices

## Core Principles

### 1. Utility-First, Avoid `@apply`
**Avoid using `@apply` in CSS files.** It re-introduces the problems of traditional CSS (naming things, file jumping) that Tailwind solves.

```css
/* ‚ùå Bad */
.btn-primary {
  @apply bg-blue-500 text-white px-4 py-2 rounded;
}
```

```tsx
/* ‚úÖ Good */
function Button({ children }) {
  return <button className="bg-blue-500 text-white px-4 py-2 rounded">{children}</button>;
}
```
*Exception: Overriding styles of third-party libraries where you cannot control the markup.*

### 2. Mobile-First Responsiveness
**Write styles for mobile first**, then "add" styles for larger screens.

```tsx
/* ‚ùå Bad - Desktop first mentally */
<div className="w-1/2 xs:w-full">
```

```tsx
/* ‚úÖ Good - Mobile default, expand on desktop */
<div className="w-full md:w-1/2">
```

### 3. Use `tailwind-merge` with `clsx`
When building reusable components that accept `className` props, **ALWAYS** use `tailwind-merge` (`twMerge`) combined with `clsx` (or `cn` helper) to safely merge classes.

```tsx
import { twMerge } from 'tailwind-merge';
import { clsx, type ClassValue } from 'clsx';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Usage
export function Card({ className, children }: Props) {
  // If className has 'p-0', it will correctly override 'p-6'
  return <div className={cn("bg-white p-6 rounded-lg", className)}>{children}</div>;
}
```

## Styling Patterns

### 1. Design Tokens over Arbitrary Values
Avoid square bracket notation for colors or spacing unless absolutely unique.

```tsx
/* ‚ùå Bad - Magic values */
<div className="bg-[#123456] p-[13px]">

/* ‚úÖ Good - Theme tokens */
<div className="bg-primary-900 p-4">
```

### 2. Logical Grouping
Group classes in a consistent order to improve readability.
1. **Layout**: `flex`, `grid`, `absolute`, `relative`
2. **Box Model**: `w-`, `h-`, `p-`, `m-`
3. **Typography**: `text-`, `font-`
4. **Visuals**: `bg-`, `border-`, `shadow-`, `opacity-`
5. **Interactive**: `hover:`, `focus:`

### 3. Handle Dynamic Classes Safely
Do not construct class strings dynamically in a way that breaks the Tailwind compiler/scanner.

```tsx
/* ‚ùå Bad - Parser can't see the full class name */
<div className={`text-${error ? 'red' : 'green'}-500`}>

/* ‚úÖ Good - Full class names */
<div className={error ? 'text-red-500' : 'text-green-500'}>
```

## Checklist before PR
- [ ] No new `.css` files created (unless for global reset).
- [ ] No `@apply` used in components.
- [ ] All reusable components accept a `className` prop.
- [ ] `cn()` or `twMerge` used for merging checks.
- [ ] Responsiveness verified (mobile layout looks good).

---

---
trigger: always
description: TDD workflow and testing strategy - tests before code, verification requirements.
---

# Testing Strategy & TDD Workflow

## 1. TDD Workflow (Required)
**Follow strict Test-Driven Development:**

1. **Propose Test Cases**: Before coding, outline what you will test.
2. **Clarify**: Ask user if requirements are ambiguous.
3. **Write Tests**: Create failing tests defining expected behavior.
4. **Red**: Confirm tests fail.
5. **Green**: Write minimum code to pass.
6. **Refactor**: improve code while keeping tests passing.

### Test Plan Template
Use this to propose tests to the user:
```markdown
## Proposed Test Cases for [Feature]
### Happy Path
- [ ] [Description]
### Edge/Error Cases
- [ ] Empty/Null inputs
- [ ] Network failures / Permission denied
```

## 2. Testing Pyramid & Tools

| Layer | Tool | Scope | Command |
|-------|------|-------|---------|
| **E2E** | Playwright | Critical user flows | `npm run test:e2e` |
| **Integration** | Vitest + Emulators | Firestore rules, Functions | `npm run test:integration` |
| **Component** | Storybook | UI interactions (`play` functions) | `npm run test-storybook` |
| **Unit** | Vitest | Logic, Hooks, Utils | `npm run test` |
| **Static** | ESLint/TSC | Code quality, Types | `npm run verify` |

## 3. What to Test
- **Unit**: Complex logic, custom hooks, utils. Mock dependencies with `vi.mock()`.
- **Component**: User interactions (clicks, forms). Don't test style details.
- **Integration**: Security rules, backend triggers (use Emulators).
- **Skip**: Simple presentational components, 3rd party config.

## 4. Vitest Best Practices

### Mocking
```typescript
import { vi, type Mock } from 'vitest';

vi.mock('../lib/firestore');
const mockedFn = someFn as Mock;
mockedFn.mockResolvedValue({ id: '123' });
```

### Cleanup
```typescript
afterEach(() => {
  vi.clearAllMocks();
});
```

## 5. Verification
Run `npm run verify` before *every* commit. It runs lint, types, tests, and build checks.

### Debugging
- Check error message -> Check recent changes -> Run in isolation.
- Use `npm run test:watch` for interactive development.
- Ensure the development environment is ready.

---

---
trigger: model_decision
description: Standards for building UI components with React, TypeScript, and Storybook.
---

# UI Component Standards

## Design Principles
1. **Single Responsibility**: One thing well. Split if >150 lines.
2. **Props-Based**: No internal data fetching. Use callbacks for actions.
3. **Type Safety**: strict interfaces for Props. Export them.

```tsx
interface ButtonProps {
  variant: 'primary' | 'secondary';
  onClick?: () => void;
  children: React.ReactNode;
}
```

## Storybook Development
**Workflow:**
1. **Build in Storybook**: Don't integrate until the component works in isolation.
2. **Variations**: Create stories for Primary, Disabled, Loading, Error, Empty.
3. **Interaction**: Use `play` functions to test behavior.
4. **Accessibility**: Check the a11y addon tab.

**Story Example:**
```tsx
const meta: Meta<typeof Button> = { component: Button };
export default meta;

export const Primary: Story = { args: { variant: 'primary' } };
export const Interaction: Story = {
  play: async ({ canvas }) => {
    await canvas.getByRole('button').click();
  }
};
```

## Styling (CSS Modules)
- Use `.module.css` files.
- CamelCase class names: `styles.buttonPrimary`.
- Scope styles strictly to the component.

## Accessibility Checklist
- [ ] Semantic HTML (`<button>` not `<div>`)
- [ ] Visible focus states
- [ ] Keyboard navigation support
- [ ] Color contrast (WCAG AA)
- [ ] Appropriate ARIA labels where needed

---

---
trigger: model_decision
description: Zustand state management patterns and best practices.
---

# Zustand Patterns

## Store Structure

**Keep stores focused and small:**

```typescript
interface AuthStore {
  user: User | null;
  isLoading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  isLoading: true,
  signIn: async (email, password) => {
    set({ isLoading: true });
    const user = await authService.signIn(email, password);
    set({ user, isLoading: false });
  },
  signOut: async () => {
    await authService.signOut();
    set({ user: null });
  },
}));
```

## Selectors

**Use selectors to prevent unnecessary re-renders:**

```typescript
// ‚ùå Bad - component re-renders on ANY store change
function UserProfile() {
  const store = useAuthStore();
  return <div>{store.user?.name}</div>;
}

// ‚úÖ Good - only re-renders when user changes
function UserProfile() {
  const user = useAuthStore((state) => state.user);
  return <div>{user?.name}</div>;
}

// ‚úÖ Good - select multiple values
function AuthStatus() {
  const { user, isLoading } = useAuthStore(
    (state) => ({ user: state.user, isLoading: state.isLoading })
  );
}
```

## Async Actions & Optimistic Updates

**Distinguish between fetching data and mutating data:**

### 1. Fetching (Global Loading)
Use `isLoading` for initial data fetches where the page cannot render without data.

```typescript
fetchEvents: async () => {
  set({ isLoading: true, error: null });
  try {
    const events = await eventService.getAll();
    set({ events, isLoading: false });
  } catch (error) {
    set({ error: 'Failed to load events', isLoading: false });
  }
},
```

### 2. Mutating (Optimistic Updates)
**NEVER** trigger a global loading state for small user actions (like toggling a vote or editing a name). It causes jarring UI flashes.
Instead, update the local state **immediately**, then sync with the backend.

```typescript
toggleVote: async (eventId: string) => {
  // 1. Snapshot previous state (optional, for rollback)
  const previousEvents = get().events;

  // 2. Optimistic Update (Instant feedback)
  set((state) => ({
    events: state.events.map(e => 
      e.id === eventId ? { ...e, voted: !e.voted } : e
    )
  }));

  // 3. Sync with Backend
  try {
    await api.toggleVote(eventId);
  } catch (error) {
    // 4. Rollback on error
    console.error('Vote failed:', error);
    set({ events: previousEvents, error: 'Failed to vote' });
  }
},
```

## Store Organization

```
src/lib/stores/
‚îú‚îÄ‚îÄ useAuthStore.ts      # Authentication state
‚îú‚îÄ‚îÄ useEventStore.ts     # Event data
‚îú‚îÄ‚îÄ useBakerStore.ts     # Baker data
‚îî‚îÄ‚îÄ useUIStore.ts        # UI state (modals, toasts)
```

## When to Use Zustand vs Local State

| Use Case | Solution |
|----------|----------|
| Form input values | `useState` |
| Modal open/closed | `useState` |
| Current user | Zustand |
| Shared data across routes | Zustand |
| Server cache | Zustand or React Query |

## Zustand Checklist

- [ ] Stores are focused (single responsibility)
- [ ] Selectors used to prevent unnecessary re-renders
- [ ] Loading and error states handled in async actions
- [ ] Store actions handle their own errors

---

