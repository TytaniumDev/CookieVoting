---
trigger: model_decision
description: Zustand state management patterns and best practices.
generatedAt: "2026-01-13T06:50:16Z"
sourceChecksum: "6a8fa8edd2f3"
---

> ⚠️ **AUTO-GENERATED** — Do not edit this file. Edit `ai/rules/zustand-patterns.md` instead.


# Zustand Patterns

## Store Structure

**Keep stores focused and small:**

```typescript
interface AuthStore {
  user: User | null;
  isLoading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  isLoading: true,
  signIn: async (email, password) => {
    set({ isLoading: true });
    const user = await authService.signIn(email, password);
    set({ user, isLoading: false });
  },
  signOut: async () => {
    await authService.signOut();
    set({ user: null });
  },
}));
```

## Selectors

**Use selectors to prevent unnecessary re-renders:**

```typescript
// ❌ Bad - component re-renders on ANY store change
function UserProfile() {
  const store = useAuthStore();
  return <div>{store.user?.name}</div>;
}

// ✅ Good - only re-renders when user changes
function UserProfile() {
  const user = useAuthStore((state) => state.user);
  return <div>{user?.name}</div>;
}

// ✅ Good - select multiple values
function AuthStatus() {
  const { user, isLoading } = useAuthStore(
    (state) => ({ user: state.user, isLoading: state.isLoading })
  );
}
```

## Async Actions & Optimistic Updates

**Distinguish between fetching data and mutating data:**

### 1. Fetching (Global Loading)
Use `isLoading` for initial data fetches where the page cannot render without data.

```typescript
fetchEvents: async () => {
  set({ isLoading: true, error: null });
  try {
    const events = await eventService.getAll();
    set({ events, isLoading: false });
  } catch (error) {
    set({ error: 'Failed to load events', isLoading: false });
  }
},
```

### 2. Mutating (Optimistic Updates)
**NEVER** trigger a global loading state for small user actions (like toggling a vote or editing a name). It causes jarring UI flashes.
Instead, update the local state **immediately**, then sync with the backend.

```typescript
toggleVote: async (eventId: string) => {
  // 1. Snapshot previous state (optional, for rollback)
  const previousEvents = get().events;

  // 2. Optimistic Update (Instant feedback)
  set((state) => ({
    events: state.events.map(e => 
      e.id === eventId ? { ...e, voted: !e.voted } : e
    )
  }));

  // 3. Sync with Backend
  try {
    await api.toggleVote(eventId);
  } catch (error) {
    // 4. Rollback on error
    console.error('Vote failed:', error);
    set({ events: previousEvents, error: 'Failed to vote' });
  }
},
```

## Store Organization

```
src/lib/stores/
├── useAuthStore.ts      # Authentication state
├── useEventStore.ts     # Event data
├── useBakerStore.ts     # Baker data
└── useUIStore.ts        # UI state (modals, toasts)
```

## When to Use Zustand vs Local State

| Use Case | Solution |
|----------|----------|
| Form input values | `useState` |
| Modal open/closed | `useState` |
| Current user | Zustand |
| Shared data across routes | Zustand |
| Server cache | Zustand or React Query |

## Zustand Checklist

- [ ] Stores are focused (single responsibility)
- [ ] Selectors used to prevent unnecessary re-renders
- [ ] Loading and error states handled in async actions
- [ ] Store actions handle their own errors
