---
trigger: model_decision
description: Firebase/Firestore coding patterns and best practices.
generatedAt: "2025-12-27T02:08:39Z"
sourceChecksum: "19cd54107b76"
---

> ⚠️ **AUTO-GENERATED** — Do not edit this file. Edit `ai/rules/firebase-patterns.md` instead.


# Firebase Patterns

## Firestore Queries

**Always handle loading and error states:**

```typescript
function useEvent(eventId: string) {
  const [event, setEvent] = useState<Event | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const unsubscribe = onSnapshot(
      doc(db, 'events', eventId),
      (snapshot) => {
        setEvent(snapshot.exists() ? { id: snapshot.id, ...snapshot.data() } as Event : null);
        setIsLoading(false);
      },
      (err) => {
        setError(err);
        setIsLoading(false);
      }
    );
    return unsubscribe;
  }, [eventId]);

  return { event, isLoading, error };
}
```

## Real-time Subscriptions

**Always clean up listeners:**

```typescript
useEffect(() => {
  const unsubscribe = onSnapshot(collection(db, 'events'), (snapshot) => {
    // handle data
  });
  
  return () => unsubscribe(); // Clean up!
}, []);
```

## Batched Writes

**Use batches for multiple operations:**

```typescript
async function updateEventWithBakers(eventId: string, bakerIds: string[]) {
  const batch = writeBatch(db);
  
  batch.update(doc(db, 'events', eventId), { 
    updatedAt: serverTimestamp() 
  });
  
  bakerIds.forEach((bakerId) => {
    batch.update(doc(db, 'bakers', bakerId), { eventId });
  });
  
  await batch.commit();
}
```

## Timestamps

**Always use server timestamps:**

```typescript
import { serverTimestamp } from 'firebase/firestore';

await addDoc(collection(db, 'events'), {
  name: 'Cookie Contest',
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp(),
});
```

## Firebase in Hooks Only

**Keep Firebase out of components:**

```typescript
// ❌ Bad - Firebase in component
function EventList() {
  useEffect(() => {
    const q = query(collection(db, 'events'));
    // Firebase logic in component...
  }, []);
}

// ✅ Good - Firebase in custom hook
function EventList() {
  const { events, isLoading } = useEvents();
  // Component only handles rendering
}
```

## Error Handling

**Provide user-friendly error messages:**

```typescript
async function createEvent(data: EventData) {
  try {
    await addDoc(collection(db, 'events'), data);
  } catch (error) {
    if (error.code === 'permission-denied') {
      throw new Error('You do not have permission to create events');
    }
    if (error.code === 'unavailable') {
      throw new Error('Unable to connect. Check your internet connection');
    }
    throw new Error('Failed to create event. Please try again');
  }
}
```

## Security Considerations

**Never trust client-side data - let security rules validate:**

```typescript
// In firestore.rules, validate ownership:
// allow create: if request.auth.uid == request.resource.data.createdBy;
```

## Firebase Checklist

- [ ] All listeners cleaned up on unmount
- [ ] Server timestamps used for dates
- [ ] Error messages are user-friendly
- [ ] Batch writes used for multiple operations
- [ ] Firebase logic lives in hooks, not components
