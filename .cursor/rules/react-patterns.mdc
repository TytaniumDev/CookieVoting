---
trigger: model_decision
description: React patterns including hooks, component design, and performance optimization.
generatedAt: "2025-12-26T02:56:50Z"
sourceChecksum: "4524808863ce"
---

> ⚠️ **AUTO-GENERATED** — Do not edit this file. Edit `ai/rules/react-patterns.md` instead.


# React Patterns & Best Practices

## Core Principles
1. **Unidirectional Data Flow**: Data flows down, actions flow up.
2. **Composition over Inheritance**: Use `children` prop and composition to build complex UIs.
3. **Immutable State**: Never mutate state directly; use setters.
4. **Separation of Concerns**: Logic in hooks, UI in components.

## Hooks Rules
1. **Top Level Only**: Never call hooks in loops, conditions, or nested functions.
2. **React Functions Only**: Call from components or custom hooks.
3. **Dependencies**: `useEffect`, `useCallback`, `useMemo` dependency arrays must be exhaustive.
4. **Naming**: Custom hooks must start with `use`.

### Common Hooks Usage
- **useState**: For local UI state. Use functional updates `setCount(c => c + 1)` for state dependent on previous value.
- **useEffect**: For side effects (subscriptions, DOM). **Always return a cleanup function**.
- **useContext**: To avoid prop drilling global data (auth, theme).
- **useMemo/useCallback**: Memoize expensive calculations or functions passed to memoized children.

## Component Patterns

### Container/Presenter
Separate data fetching/logic from rendering.
```tsx
// Container: Handles logic & data
const UserProfile = ({ id }) => {
  const { user, loading } = useUser(id);
  if (loading) return <Spinner />;
  return <UserProfileView user={user} />;
};

// Presenter: Pure UI
const UserProfileView = ({ user }) => <h1>{user.name}</h1>;
```

### Compound Components
For components that work together (e.g., Tabs, Card).
```tsx
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
</Card>
```

## Performance Optimization

### Rendering
- **Minimize State**: Derive values during render where possible.
- **React.memo**: Wrap pure functional components to prevent re-renders when props haven't changed.
- **Stable Props**: Use `useCallback` for event handlers passed to child components.
- **Virtualization**: Use `react-window` for long lists.

### Code Splitting
- **Lazy Loading**: Use `React.lazy` and `Suspense` for route-based splitting.
- **Dynamic Imports**: Import heavy libraries on demand.

## Anti-Patterns to Avoid
- **Prop Drilling**: Passing props through >2 layers (use Composition or Context).
- **Large Components**: Split components >150 lines.
- **Logic in JSX**: Move complex conditionals/maps to variables or sub-components.
- **Derived State in State**: Don't store `fullName` if you have `firstName` and `lastName`.

## React Checklist
- [ ] Hooks follow strict ordering and dependency rules
- [ ] Components are small (<150 lines) and focused
- [ ] State is lifted to the lowest common ancestor
- [ ] Expensive calculations are memoized
- [ ] No direct Firebase calls in components (use hooks)
