# CLAUDE.md - Project Instructions

> **‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT EDIT THIS FILE DIRECTLY**
>
> **Source:** `.ai/rules/` ‚Äî All edits must be made there, not here.
>
> **Last synced:** December 23, 2025 at 00:09:02 UTC ¬∑ Checksum: `1d0b4e6bbbfb`

## ü§ñ Instructions for AI Agents

**DO NOT modify this file.** Instead:

1. **To update instructions:** Edit the source files in `.ai/rules/` directory
2. **After editing:** Run `npm run dev` or `npm run sync-agent-rules` to regenerate all agent files
3. **If you notice recurring issues:** Please proactively update the relevant file in `.ai/rules/` to prevent the issue from happening again. Add new rules, clarify existing ones, or document patterns that help.

The source files are:
- `.ai/rules/01-project-guidelines.md` - Core project standards
- `.ai/rules/02-ui-components.md` - UI/React component rules  
- `.ai/rules/03-firebase-deployment.md` - Firebase deployment rules
- `.ai/rules/04-testing-strategy.md` - Testing requirements

**When to update the rules:**
- You keep making the same mistake ‚Üí Add a rule to prevent it
- A rule is unclear or incomplete ‚Üí Clarify it
- You discover a new best practice ‚Üí Document it
- The user corrects you on something ‚Üí Add it as a rule

---

# Project Guidelines & Standards

This document outlines the core development practices for the CookieVoting project.

## Core Principles

### 1. Thinking in React

Follow the 5-step process:

- Break UI into components.
- Build a static version.
- Minimize state.
- Identify state location.
- Add inverse data flow.

### 2. UI Development

- **No Firebase in UI**: Components must NEVER directly import Firebase services (`firestore`, `auth`, `storage`). All interactions must happen through custom hooks in `src/lib/hooks/`.
- **Storybook First**: Build all UI in Storybook before integration.
- **Automated Interaction Tests**: **REQUIRED**. Every complex component must have a Storybook story with a `play` function that verifies the critical user journey (e.g., clicking next after voting). This is strictly PREFERRED over manual verification or generic browser tests for UI logic.
- **Atomic Design**:
  - **Atoms**: Reusable UI primitives (Buttons, Inputs, Modals). Location: `src/components/atoms/`.
  - **Molecules**: Combinations of atoms with minimal logic. Location: `src/components/molecules/`.
  - **Organisms**: Complex, self-contained components or sections. Location: `src/components/organisms/`.
- **Accessibility**: Use semantic HTML, ARIA attributes, and ensure keyboard navigation.
- **Testability**:
  - Add unique `data-testid` or `id` attributes to all interactive elements to facilitate native tool selection.
  - Use clear, descriptive ARIA labels where visual labels aren't sufficient.

### 3. Firebase Resource Management

- **Security Rules**:
  - Firestore rules do NOT support `if` statements (use ternary).
  - No `const` or `let` in rules.
  - Multi-line conditionals should use `&&` or `||`.
- **Functions**:
  - Always build before deploying using `npm run build --prefix functions`.
  - Use `DETECTION_FUNCTION_VERSION` for tracking logic versions.

## Code Standards

### Naming Conventions

- **Components**: `PascalCase` (e.g., `CookieViewer.tsx`).
- **Props/Variables**: `camelCase`.
- **Hooks**: `use` prefix (e.g., `useAuth`).
- **Files**: Match component/class name.

- Keep state local whenever possible.
- Lift state to the lowest common ancestor.
- **Custom Hooks**: Extract all Firebase interaction and business logic into custom hooks. Hooks should handle loading/error states and provide clean APIs to components.
- **Utility Functions**: Move complex, non-React logic (e.g., sorting, coordinate calculations) to `src/lib/` utilities.

## Deployment & Verification

- **Build Before Reporting**: Make sure the app builds successfully before reporting a change.
- **Verify Before Reporting**: **REQUIRED**. Run `npm run verify` before reporting ANY code changes. This script mirrors the GitHub CI pipeline (Lint, Test, Build) and catches errors that would break the build. Fix ALL lint warnings and errors before reporting.
- **Efficient Verification**:
  - **Minimize Prompts**: To avoid excessive approval requests, prefer `read_url_content` for static state checks.
  - **NO Custom JS**: Custom JavaScript execution using browser tools is strictly FORBIDDEN unless no native alternative exists. Prefer native browser tools (click, get_text) to avoid the mandatory manual approval step.
  - **Interactive Tasks**: Use `browser_subagent` only for tasks requiring JS execution (e.g., Storybook, animations, complex navigation).
  - **Mission Batching**: Batch multiple verification steps into a single `browser_subagent` call to reduce the number of times the user needs to approve a subagent mission.
- **Automatic Debugging**: Attempt to fix testing failures automatically before informing the user.
- **Deployment**: Use `npm run firebase:deploy:*` scripts for safety.

## Local Emulator Development

- **Start Emulators**: Use `npm run emulators:start:seed` to start with a fresh test environment seeded with data.
- **Unified Auth**: No custom "test user" system exists. Use the standard "Sign in with Google" flow. The emulator will prompt you to select or create a mock account.
- **Admin Access**: The seeding script automatically adds `test@local.dev` (UID: `test-user-default`) to `system/admins`. Use this account for admin functionality.
- **Connectivity (Windows)**: Use `127.0.0.1` instead of `localhost` in Firebase configuration to avoid IPv6 connection timeouts.

---

# UI Component Creation Standards

## Core Principles of Reusable React Components

When developing or modifying UI components, follow these three core principles: **modularity**, **maintainability**, and **flexibility**. These ensure components remain adaptable, easy to manage, and reusable across projects.

### 1. Single Responsibility Principle
- Each component should have **one clear purpose** and handle a single responsibility.
- Break down complex UIs into smaller, manageable sub-components.
- If a component is doing too much, split it into multiple focused components.

### 2. Separation of Concerns
- UI components should be **modular** and **reusable**.
- **Do NOT include business logic** (e.g., data fetching, external side effects) inside reusable components.
- Components should accept all necessary state or data via props and should not depend on global state or app-specific logic.
- Use patterns like **Container/Presenter** or **Custom Hooks** to separate logic from presentation.

### 3. NO Firebase Dependencies in UI Components
- **UI components MUST NEVER directly import or use Firebase services** (auth, db, storage, functions).
- **Components should receive all data and callbacks via props** instead of fetching data themselves.
- Firebase logic belongs in:
  - Custom hooks (e.g., `useAuth`, `useImageDetections`) in `src/lib/hooks/`
  - Utility functions in `src/lib/firestore.ts`, `src/lib/storage.ts`, etc.
  - Parent components or pages that use the hooks and pass data/callbacks to UI components

## Storybook Development Workflow

### 1. ALWAYS Build in Storybook First
- All new UI components and widgets MUST be created and thoroughly tested in Storybook BEFORE integration into the application.
- Use the built-in browser to interactively verify **all behaviors** and **visuals** in Storybook.

### 2. Testability and Testing
- **All component states must be demonstrable in Storybook.**
- If your component has disabled, error, loading, empty, selected, or interactive states, **create a dedicated Story for each one**.
- Since components don't use Firebase directly, you can pass mock data/callbacks in stories without any Firebase setup.

### 3. Storybook Testing Framework
- **ALWAYS add interaction tests** using `play` functions for interactive components.
- Use `play` functions to test user interactions like clicks, form submissions, and state changes.
- Import testing utilities from `storybook/test`: `import { fn, expect } from 'storybook/test'`
- Use `fn()` to create mock functions that can be spied on: `onClick: fn()`

Example:
```tsx
export const Interactive: Story = {
  args: {
    onClick: fn(),
  },
  play: async ({ canvas, args }) => {
    const button = canvas.getByRole('button');
    await button.click();
    await expect(args.onClick).toHaveBeenCalled();
  },
};
```

## Component Design Patterns

### Atomic Design Methodology
Organize components into a hierarchical structure:

- **Atoms**: Smallest, indivisible elements (buttons, inputs, labels, icons)
- **Molecules**: Groups of atoms that work together (search bar = input + button)
- **Organisms**: Complex UI sections made of molecules (navigation bar, form sections)

**Project Structure:**
```
components/
  atoms/
    Button/
    Input/
    Label/
  molecules/
    SearchBar/
    FormField/
  organisms/
    Navigation/
    Card/
```

## Accessibility (A11y)

**Components MUST be accessible by default:**

- **Semantic HTML**: Use appropriate HTML elements (`<button>`, `<nav>`, `<main>`, etc.)
- **ARIA Attributes**: Add ARIA labels, roles, and states when semantic HTML isn't sufficient
- **Keyboard Navigation**: Ensure all interactive elements are keyboard accessible
- **Focus Management**: Properly manage focus states and focus trapping in modals
- **Color Contrast**: Meet WCAG AA standards (4.5:1 for normal text, 3:1 for large text)

---

# Firebase Deployment Rules

## When to Deploy

The agent should automatically deploy Firebase resources when:

### 1. Function Source Code Changes (`functions/src/`)
- After any modification to `.ts` files in `functions/src/`
- Command: `npm run firebase:deploy:functions`

### 2. Function Dependencies Changes (`functions/package.json`)
- After any modification to `functions/package.json` (dependencies added/updated)
- Command: `npm run firebase:deploy:functions`

### 3. Firestore Rules Changes (`firebase/firestore.rules`)
- After any modification to `firestore.rules`
- Command: `npm run firebase:deploy:firestore`

### 4. Storage Rules Changes (`firebase/storage.rules`)
- After any modification to `storage.rules`
- Command: `npm run firebase:deploy:storage`

## Deployment Process

### Before Deploying:
- Verify the functions compile successfully (TypeScript compilation)
- Check for any syntax errors
- Ensure changes are intentional and correct

### Available npm Scripts:
- `npm run firebase:deploy:functions` - Build and deploy Firebase Functions
- `npm run firebase:deploy:rules` - Deploy both Firestore and Storage rules
- `npm run firebase:deploy:firestore` - Deploy only Firestore rules
- `npm run firebase:deploy:storage` - Deploy only Storage rules

### After Deploying:
- Verify deployment success in output
- Note any warnings or errors
- Inform user of deployment completion

## Important Notes

### Firestore Rules Syntax Restrictions:
- Firestore rules do NOT support `if` statements (use ternary operators instead)
- No `const` or `let` declarations (use direct expressions)
- Multi-line conditionals (use `&&` and `||` operators)

### What NOT to Deploy:
- ‚ùå **DON'T deploy** when only documentation files are changed (`.md` files)
- ‚ùå **DON'T deploy** when only frontend code is changed (`src/` outside of functions)
- ‚ùå **DON'T deploy** when only test files are changed (unless they affect function logic)

## Error Handling

If deployment fails:
1. Read the error message carefully
2. Check TypeScript compilation errors
3. Fix syntax/compilation errors
4. Retry deployment
5. If persistent issues, inform user with specific error details

---

# Testing Strategy

Rules for creating or modifying tests following standard practices.

## Testing Pyramid & Philosophy

Follow the modified testing pyramid adapted for the Firebase + React stack:

1. **Static Analysis**: First line of defense.
2. **Unit Tests (`src/lib`, `functions`)**: Fast, isolated logic tests using Vitest.
3. **Component Tests (Storybook)**: **REQUIRED** for UI. Use `play` functions for user interactions.
4. **Integration Tests (Firebase Emulators)**: Verify backend interactions using Jest.
5. **E2E Tests (Playwright)**: Critical user full-stack journeys.

## Rules & Standards

### Unit Tests
- **Scope**: `src/lib/`, `src/hooks/`, `functions/src/`.
- **Mocking**: Mock Firebase calls. Use Integration tests for real behavior.
- **Coverage Goal**: Aim for high coverage on utility logic.

### Component Interaction Tests (Storybook)
- **Tool**: Storybook + `@storybook/addon-interactions`.
- **Requirement**: Every complex interactive component MUST have a `ValidUserJourney` story simulating a successful interaction.
- **Accessibility**: Use `storybook-addon-a11y`.

### Integration Tests
- **Environment**: Must run against `npm run emulators:start`.
- **Scope**: Security rules, triggers, complex queries.

### E2E Tests
- **Tool**: Playwright.
- **Focus**: Critical user journeys (e.g., Voting Flow, Admin Event Setup).

## Verification Commands

- **Unit/Coverage**: `npm run test:coverage`
- **Storybook**: `npm run test-storybook`
- **Integration**: `npm run test:integration`
- **E2E**: `npm run test:e2e`
- **All**: `npm run verify`

## Verification Workflow

1. **Start Emulators**: Ensure emulators are running with seed data.
   - Run: `npm run emulators:start:seed`
2. **Open Application**: Navigate to `http://localhost:5173/` in the built-in browser.
3. **Sign In**: Click "Sign in with Test User" and verify redirect to `/admin`.
4. **Test Feature**: Perform actions relevant to the changes. Verify UI updates, data persistence, and lack of console errors.
5. **Debug**: Use browser dev tools (console messages) to identify and fix issues before re-testing.

---

