# CLAUDE.md - Project Instructions

> **‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT EDIT THIS FILE DIRECTLY**
>
> **Source:** `ai/rules/` ‚Äî All edits must be made there, not here.
>
> **Last synced:** December 24, 2025 at 13:01:01 PST ¬∑ Checksum: `cf5a4f9fe572`

## ü§ñ Instructions for AI Agents

**DO NOT modify this file.** Instead:

1. **To update instructions:** Edit the source files in `ai/rules/` directory
2. **After editing:** Run `npm run dev` or `npm run sync-agent-rules` to regenerate all agent files
3. **If you notice recurring issues:** Please proactively update the relevant file in `ai/rules/` to prevent the issue from happening again. Add new rules, clarify existing ones, or document patterns that help.

**Source files:** All `.md` files in `ai/rules/` directory.

**When to update the rules:**
- You keep making the same mistake ‚Üí Add a rule to prevent it
- A rule is unclear or incomplete ‚Üí Clarify it
- You discover a new best practice ‚Üí Document it
- The user corrects you on something ‚Üí Add it as a rule

---

You are an expert in React component patterns.

Key Principles:
- Composition over inheritance
- Separation of concerns
- Reusability and maintainability
- Clean and readable code

Common Patterns:
- Compound Components: Flexible parent-child relationship
- Render Props: Share code between components
- Higher-Order Components (HOC): Reuse component logic
- Custom Hooks: Reuse stateful logic
- Controlled vs Uncontrolled: Form handling

Composition:
- Use children prop for flexibility
- Create layout components
- Use slots pattern
- Avoid prop drilling
- Build atomic components

Context Pattern:
- Create custom providers
- Create custom consumers/hooks
- Split context by domain
- Optimize context value memoization
- Handle missing context errors

Error Boundaries:
- Catch JavaScript errors in child components
- Log errors to service
- Display fallback UI
- Reset error state
- Wrap critical parts of app

Best Practices:
- Keep components small and focused
- Use TypeScript for props validation
- Document component API
- Write unit tests
- Use Storybook for documentation
---

---
trigger: always
description: Code quality standards for TypeScript, error handling, and maintainable code.
---

# Code Quality Standards

## TypeScript Best Practices

### Type Safety

**Avoid `any`** - It defeats the purpose of TypeScript:

```typescript
// ‚ùå Bad
function process(data: any) { ... }

// ‚úÖ Good - be specific
function process(data: UserData) { ... }

// ‚úÖ Good - use unknown if truly unknown, then narrow
function process(data: unknown) {
  if (isUserData(data)) { /* TypeScript knows it's UserData */ }
}
```

**Use strict null checks:**

```typescript
// ‚ùå Bad - might crash
function getName(user: User) {
  return user.profile.name; // What if profile is null?
}

// ‚úÖ Good - handle null cases
function getName(user: User) {
  return user.profile?.name ?? 'Anonymous';
}
```

### Type Definitions

**Define interfaces for all data shapes:**

```typescript
interface Event {
  id: string;
  name: string;
  date: Date;
  status: 'draft' | 'active' | 'completed';
}

function createEvent(data: Omit<Event, 'id'>): Event { ... }
function updateEvent(id: string, updates: Partial<Event>): void { ... }
```

**Prefer union types over enums for simple cases:**

```typescript
// ‚úÖ Preferred - simpler, better tree-shaking
type Status = 'loading' | 'success' | 'error';
```

## Error Handling

**Always handle promise rejections:**

```typescript
// ‚ùå Bad - unhandled rejection
async function fetchUser(id: string) {
  const user = await api.getUser(id);
  return user;
}

// ‚úÖ Good - explicit error handling
async function fetchUser(id: string): Promise<User | null> {
  try {
    return await api.getUser(id);
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
}
```

## Code Organization

### Keep Functions Small

```typescript
// ‚ùå Bad - does too much
function processOrder(order: Order) {
  // validate, calculate, discount, notify... 200 lines
}

// ‚úÖ Good - single responsibility
function processOrder(order: Order) {
  validateOrder(order);
  const totals = calculateTotals(order);
  const finalPrice = applyDiscounts(totals, order.coupons);
  updateInventory(order.items);
  notifyCustomer(order, finalPrice);
}
```

### Early Returns

```typescript
// ‚ùå Bad - deeply nested
function getDisplayName(user: User | null) {
  if (user) {
    if (user.profile) {
      return user.profile.displayName || user.email;
    }
    return user.email;
  }
  return 'Guest';
}

// ‚úÖ Good - flat with early returns
function getDisplayName(user: User | null) {
  if (!user) return 'Guest';
  if (!user.profile) return user.email;
  return user.profile.displayName || user.email;
}
```

### Extract Constants

```typescript
// ‚ùå Bad - magic numbers
if (cookies.length > 12) { ... }

// ‚úÖ Good - named constants
const MAX_COOKIES_PER_BAKER = 12;
if (cookies.length > MAX_COOKIES_PER_BAKER) { ... }
```

## Code Review Checklist

### General
- [ ] TypeScript compiles with no errors
- [ ] No `any` types (or justified with comment)
- [ ] Error cases are handled
- [ ] Functions are small and focused
- [ ] No console.log statements (except intentional logging)
- [ ] No commented-out code

### Testing
- [ ] Tests added for new functionality
- [ ] Storybook stories for new components

---

---
trigger: model_decision
description: Guidelines for Firebase deployments - when and how to deploy functions and security rules.
---

# Firebase Deployment Guidelines

## Deployment Safety

**Never deploy without verification.** Always:
1. Run `npm run verify` to ensure code quality
2. Test changes locally with emulators first
3. Confirm the deployment is intentional

## When to Deploy

### Cloud Functions (`functions/src/`)

Deploy after modifying:
- TypeScript files in `functions/src/`
- Function dependencies in `functions/package.json`
- TypeScript config in `functions/tsconfig.json`

**Command:** `npm run firebase:deploy:functions`

### Security Rules

Deploy after modifying:
- `firebase/firestore.rules` ‚Üí `npm run firebase:deploy:firestore`
- `firebase/storage.rules` ‚Üí `npm run firebase:deploy:storage`
- Both ‚Üí `npm run firebase:deploy:rules`

## When NOT to Deploy

Do not trigger deployment for:
- Documentation changes (`.md` files)
- Frontend-only changes (`src/` except functions)
- Test file changes (unless they reveal function bugs)
- Storybook or story changes

## Pre-Deployment Checklist

### For Functions:
- [ ] TypeScript compiles without errors: `npm run build --prefix functions`
- [ ] Related unit tests pass
- [ ] Tested against local emulators
- [ ] Changes reviewed for security implications

### For Security Rules:
- [ ] Rules syntax is valid (no `if`, `const`, `let`)
- [ ] Tested read/write scenarios in emulator
- [ ] No unintended permission changes

## Firestore Rules Syntax

Firestore rules have unique syntax requirements:

```javascript
// ‚ùå WRONG - if statements not supported
if (request.auth != null) {
  allow read;
}

// ‚úÖ CORRECT - use ternary or boolean expressions
allow read: if request.auth != null;

// ‚ùå WRONG - no variable declarations
let userId = request.auth.uid;

// ‚úÖ CORRECT - inline expressions
allow write: if request.auth.uid == resource.data.ownerId;

// ‚úÖ Use && and || for complex conditions
allow update: if request.auth != null 
              && request.auth.uid == resource.data.ownerId
              && request.resource.data.status in ['draft', 'published'];
```

## Available Scripts

| Script | Purpose |
|--------|---------|
| `npm run firebase:deploy:functions` | Build and deploy Cloud Functions |
| `npm run firebase:deploy:firestore` | Deploy Firestore security rules |
| `npm run firebase:deploy:storage` | Deploy Storage security rules |
| `npm run firebase:deploy:rules` | Deploy both Firestore and Storage rules |

## Troubleshooting Deployments

### Function Deployment Fails

1. Check TypeScript compilation: `npm run build --prefix functions`
2. Look for missing dependencies
3. Check for runtime vs build-time errors
4. Verify Firebase project configuration

### Rules Deployment Fails

1. Check for syntax errors (no `if`, `const`, `let`)
2. Validate rule structure
3. Test in Firebase console rules playground

## Post-Deployment

After successful deployment:
1. Verify the deployment in Firebase Console
2. Test critical functionality in production
3. Monitor for errors in Firebase Functions logs

---

---
trigger: model_decision
description: Firebase/Firestore coding patterns and best practices.
---

# Firebase Patterns

## Firestore Queries

**Always handle loading and error states:**

```typescript
function useEvent(eventId: string) {
  const [event, setEvent] = useState<Event | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const unsubscribe = onSnapshot(
      doc(db, 'events', eventId),
      (snapshot) => {
        setEvent(snapshot.exists() ? { id: snapshot.id, ...snapshot.data() } as Event : null);
        setIsLoading(false);
      },
      (err) => {
        setError(err);
        setIsLoading(false);
      }
    );
    return unsubscribe;
  }, [eventId]);

  return { event, isLoading, error };
}
```

## Real-time Subscriptions

**Always clean up listeners:**

```typescript
useEffect(() => {
  const unsubscribe = onSnapshot(collection(db, 'events'), (snapshot) => {
    // handle data
  });
  
  return () => unsubscribe(); // Clean up!
}, []);
```

## Batched Writes

**Use batches for multiple operations:**

```typescript
async function updateEventWithBakers(eventId: string, bakerIds: string[]) {
  const batch = writeBatch(db);
  
  batch.update(doc(db, 'events', eventId), { 
    updatedAt: serverTimestamp() 
  });
  
  bakerIds.forEach((bakerId) => {
    batch.update(doc(db, 'bakers', bakerId), { eventId });
  });
  
  await batch.commit();
}
```

## Timestamps

**Always use server timestamps:**

```typescript
import { serverTimestamp } from 'firebase/firestore';

await addDoc(collection(db, 'events'), {
  name: 'Cookie Contest',
  createdAt: serverTimestamp(),
  updatedAt: serverTimestamp(),
});
```

## Firebase in Hooks Only

**Keep Firebase out of components:**

```typescript
// ‚ùå Bad - Firebase in component
function EventList() {
  useEffect(() => {
    const q = query(collection(db, 'events'));
    // Firebase logic in component...
  }, []);
}

// ‚úÖ Good - Firebase in custom hook
function EventList() {
  const { events, isLoading } = useEvents();
  // Component only handles rendering
}
```

## Error Handling

**Provide user-friendly error messages:**

```typescript
async function createEvent(data: EventData) {
  try {
    await addDoc(collection(db, 'events'), data);
  } catch (error) {
    if (error.code === 'permission-denied') {
      throw new Error('You do not have permission to create events');
    }
    if (error.code === 'unavailable') {
      throw new Error('Unable to connect. Check your internet connection');
    }
    throw new Error('Failed to create event. Please try again');
  }
}
```

## Security Considerations

**Never trust client-side data - let security rules validate:**

```typescript
// In firestore.rules, validate ownership:
// allow create: if request.auth.uid == request.resource.data.createdBy;
```

## Firebase Checklist

- [ ] All listeners cleaned up on unmount
- [ ] Server timestamps used for dates
- [ ] Error messages are user-friendly
- [ ] Batch writes used for multiple operations
- [ ] Firebase logic lives in hooks, not components

---

---
trigger: always
description: Core project guidelines and development standards for the CookieVoting project.
---

# Project Guidelines & Standards

These are the core development practices for this project. Follow these guidelines for all code changes.

## Architecture Principles

### React Best Practices

Follow the "Thinking in React" methodology:

1. **Break UI into components** - Identify component hierarchy from the design
2. **Build a static version first** - Render UI without interactivity initially
3. **Identify minimal state** - Determine the absolute minimum state needed
4. **Determine state ownership** - Place state in the lowest common ancestor
5. **Add data flow** - Pass callbacks down for child-to-parent communication

### Separation of Concerns

- **UI components are presentation-only** - They receive data via props, never fetch it
- **Business logic lives in hooks** - Custom hooks in `src/lib/hooks/` handle data fetching, state management, and side effects
- **Utilities are pure functions** - Complex logic (sorting, calculations, formatting) goes in `src/lib/` utilities
- **No Firebase in components** - Components must NEVER import Firebase directly. All Firebase interactions happen through hooks

### Project Structure

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ atoms/        # Basic UI primitives (Button, Input, Modal)
‚îÇ   ‚îú‚îÄ‚îÄ molecules/    # Combinations of atoms (SearchBar, FormField)
‚îÇ   ‚îî‚îÄ‚îÄ organisms/    # Complex sections (Navigation, Forms)
‚îú‚îÄ‚îÄ pages/            # Route-level components
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ hooks/        # Custom React hooks (useAuth, useEvent, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ stores/       # Zustand state stores
‚îÇ   ‚îú‚îÄ‚îÄ firebase.ts   # Firebase initialization
‚îÇ   ‚îú‚îÄ‚îÄ firestore.ts  # Firestore utilities
‚îÇ   ‚îî‚îÄ‚îÄ storage.ts    # Storage utilities
‚îî‚îÄ‚îÄ stories/          # Storybook stories and test data
```

## Code Standards

### Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Components | PascalCase | `CookieViewer.tsx` |
| Hooks | camelCase with `use` prefix | `useAuth.ts` |
| Utilities | camelCase | `formatDate.ts` |
| Constants | SCREAMING_SNAKE_CASE | `MAX_COOKIES` |
| Props/Variables | camelCase | `isLoading`, `onClick` |

### File Organization

- **One component per file** - Component name matches filename
- **Co-locate related files** - Keep `.module.css`, `.stories.tsx`, and `.test.tsx` near their component
- **Index exports** - Use `index.ts` for clean imports from directories

## Development Workflow

### Before Making Changes

1. Understand the existing code patterns in the area you're modifying
2. Check for similar implementations elsewhere in the codebase
3. Consider if your change requires new tests

### Before Committing

**Always run `npm run verify`** before considering work complete. This runs:
- ESLint for code quality
- TypeScript for type checking  
- Vitest for unit tests
- Build verification

Fix ALL warnings and errors before reporting completion.

### Storybook-First Development

For UI components:
1. Create the component in Storybook first
2. Add stories for all states (default, loading, error, empty, disabled)
3. Add interaction tests using `play` functions
4. Only then integrate into the application

## Firebase Guidelines

### Security Rules Syntax

Firestore rules have specific limitations:
- ‚ùå No `if` statements - use ternary operators instead
- ‚ùå No `const` or `let` - use inline expressions
- ‚úÖ Use `&&` and `||` for complex conditions

### Local Development

- **Start emulators**: `npm run emulators:start:seed`
- **Test user**: `test@local.dev` (UID: `test-user-default`) has admin access
- **Windows users**: Use `127.0.0.1` instead of `localhost` to avoid IPv6 issues

## Accessibility Requirements

All UI must be accessible:
- Use semantic HTML elements (`<button>`, `<nav>`, `<main>`)
- Add ARIA labels where visual context is insufficient
- Ensure keyboard navigation works for all interactive elements
- Add `data-testid` attributes for testing

---

---
trigger: model_decision
description: React-specific patterns, hooks rules, and performance optimization.
---

You are an expert in React Hooks.

Key Principles:
- Follow Rules of Hooks strictly
- Use custom hooks for reusable logic
- Optimize dependency arrays
- Avoid complex logic in components

Common Hooks:
- useState: Use functional updates for state based on previous state
- useEffect: Clean up side effects, handle dependencies correctly
- useContext: Avoid deep prop drilling
- useReducer: Manage complex state logic
- useRef: Access DOM nodes or mutable values

Performance Hooks:
- useMemo: Memoize expensive calculations
- useCallback: Memoize functions passed to children
- useTransition: Handle non-urgent state updates
- useDeferredValue: Defer updating UI parts

Custom Hooks:
- Start name with 'use'
- Encapsulate complex logic
- Return consistent API
- Handle errors internally
- Document usage clearly

Best Practices:
- Don't call hooks inside loops or conditions
- Keep effects focused on one concern
- Use ESLint plugin for hooks
- Avoid stale closures
- Memoize context values
---

---
trigger: model_decision
description: React-specific patterns, hooks rules, and performance optimization.
---

# React Patterns

## Hooks Rules

1. Only call hooks at the top level (not in loops, conditions, or nested functions)
2. Only call hooks from React functions (components or custom hooks)
3. Custom hooks must start with `use`

## Dependency Arrays

**Be explicit and complete:**

```typescript
// ‚ùå Bad - missing dependency
useEffect(() => {
  fetchUser(userId);
}, []); // userId should be in deps

// ‚úÖ Good - all dependencies listed
useEffect(() => {
  fetchUser(userId);
}, [userId]);

// ‚úÖ Good - use useCallback for stable references
const handleSubmit = useCallback(() => {
  submitForm(formData);
}, [formData]);
```

## Memoization

**Memoize expensive operations, not everything:**

```typescript
// ‚úÖ Good use - expensive calculation
const sortedItems = useMemo(
  () => items.sort((a, b) => b.score - a.score),
  [items]
);

// ‚ùå Unnecessary - simple value
const isActive = useMemo(() => status === 'active', [status]);
// Just use: const isActive = status === 'active';
```

## Component Patterns

### Container/Presenter

Separate data fetching from presentation:

```typescript
// Presenter - pure UI, receives everything via props
function UserProfileView({ user, onEdit, isLoading }: Props) {
  if (isLoading) return <Spinner />;
  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={onEdit}>Edit</button>
    </div>
  );
}

// Container - handles data and logic
function UserProfile({ userId }: { userId: string }) {
  const { user, isLoading } = useUser(userId);
  const handleEdit = () => { /* ... */ };
  return <UserProfileView user={user} onEdit={handleEdit} isLoading={isLoading} />;
}
```

### Compound Components

For related components that share context:

```typescript
const Card = ({ children }: { children: React.ReactNode }) => (
  <div className={styles.card}>{children}</div>
);

Card.Header = ({ children }: { children: React.ReactNode }) => (
  <div className={styles.header}>{children}</div>
);

Card.Body = ({ children }: { children: React.ReactNode }) => (
  <div className={styles.body}>{children}</div>
);

// Usage
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
</Card>
```

## State Management

### Local vs Lifted State

- **Local state**: UI-only concerns (open/closed, hover, focus)
- **Lifted state**: Shared between siblings (form data, selections)
- **Global state**: App-wide concerns (auth, theme, notifications)

### Avoid Prop Drilling

When passing props through many levels:
1. First, try lifting state to a closer common ancestor
2. Consider using context for truly global state
3. Use Zustand for complex state that many components need

## React Checklist

- [ ] Components receive data via props (no direct Firebase)
- [ ] Hooks follow rules (top-level, proper dependencies)
- [ ] Memoization used only where needed
- [ ] State lives at the appropriate level

---

You are an expert in React performance optimization.

Key Principles:
- Measure before optimizing
- Minimize re-renders
- Optimize bundle size
- Use code splitting
- Virtualize long lists

Rendering Optimization:
- Use React.memo for pure components
- Stabilize props with useMemo/useCallback
- Avoid inline functions in render
- Use key prop correctly
- Split large components

Code Splitting:
- Use React.lazy and Suspense
- Route-based code splitting
- Component-based code splitting
- Lazy load libraries
- Prefetch critical resources

State Management:
- Keep state local when possible
- Avoid large context providers
- Use atomic state libraries (Zustand, Jotai)
- Normalize state structure
- Batch state updates

Assets:
- Optimize images (Next.js Image)
- Lazy load images and videos
- Use SVGs correctly
- Preload critical fonts
- Minimize third-party scripts

Tools:
- React DevTools Profiler
- Chrome Performance Tab
- Bundle Analyzer
- Lighthouse
- Web Vitals
---

---
trigger: always
description: Test-Driven Development workflow and testing requirements for all code changes.
---

# Testing Strategy

## Test-Driven Development (TDD) Workflow

**This project follows strict Test-Driven Development.** Write tests BEFORE implementation code.

### The TDD Cycle

For every code change, follow this cycle:

1. **Propose test cases first** - Before writing any implementation, outline the test cases you plan to write
2. **Clarify ambiguities** - If requirements are unclear, ASK the user before proceeding
3. **Write the tests** - Create failing tests that define expected behavior.
4. **Run tests (expect failures)** - Confirm tests fail as expected
5. **Implement the code** - Write the minimum code to make tests pass. Follow guidance in `testing-strategy.md` for test case quality standards.
6. **Run tests again** - Verify all tests pass
7. **Refactor** - Clean up code while keeping tests green
8. **Repeat** - Continue until all functionality is complete and tests pass

### Proposing Test Cases

Before writing tests, present a test plan to the user that includes:

```markdown
## Proposed Test Cases for [Feature/Function]

### Happy Path
- [ ] Test case 1: [description of expected behavior]
- [ ] Test case 2: [description of expected behavior]

### Edge Cases
- [ ] Empty input handling
- [ ] Boundary values (min/max)
- [ ] Invalid input types
- [ ] Null/undefined handling

### Error Cases
- [ ] Network failures
- [ ] Permission denied
- [ ] Invalid state transitions
```

**Ask for clarification if:**
- Requirements are ambiguous or incomplete
- Edge case behavior is not specified
- Error handling expectations are unclear
- Performance requirements are not defined

### Test Case Quality Standards

Write tests that are:
- **Readable** - Test names describe the behavior, not implementation
- **Maintainable** - Avoid testing implementation details
- **Thorough** - Cover happy paths, edge cases, and error conditions
- **Independent** - Tests should not depend on each other

```typescript
// ‚ùå Bad - tests implementation details
it('calls setLoading with true then false', () => { ... });

// ‚úÖ Good - tests behavior
it('shows loading spinner while fetching data', () => { ... });
it('displays error message when fetch fails', () => { ... });
```

### When to Skip TDD

TDD is **required** for:
- New utility functions
- Custom hooks
- Business logic
- API integrations
- Complex component interactions

TDD may be **relaxed** for:
- Simple presentational components (use Storybook visual review)
- Configuration changes
- Documentation updates
- Refactoring with existing test coverage

---

**See also:** `testing-strategy.md` for test commands, tooling, and code examples.

---

---
trigger: model_decision
description: Testing strategy and requirements for maintaining code quality.
---

# Testing Strategy

## Testing Pyramid

This project follows a testing pyramid adapted for React + Firebase:

```
         ‚ñ≤
        /E2E\        Playwright - Critical user journeys only
       /‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\
      /Integr-\      Jest + Emulators - Backend interactions
     /‚îÄ‚îÄation‚îÄ‚îÄ\
    /Component‚îÄ‚îÄ\    Storybook - UI components with play functions
   /‚îÄ‚îÄ‚îÄ‚îÄ‚îÄTests‚îÄ‚îÄ‚îÄ\
  /‚îÄ‚îÄ‚îÄUnit Tests‚îÄ‚îÄ\  Vitest - Utility functions, hooks, business logic
 /‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\
/‚îÄ‚îÄStatic Analysis‚îÄ‚îÄ\ ESLint + TypeScript - Catches issues before runtime
```

**Principle:** More tests at the bottom (fast, cheap), fewer at the top (slow, expensive).

## Test Types & Tools

### Static Analysis (Always On)
- **ESLint**: Code quality and consistency
- **TypeScript**: Type safety
- **Run**: Happens automatically, also via `npm run lint`

### Unit Tests (Vitest)
- **Scope**: `src/lib/`, custom hooks, utility functions
- **Approach**: Test pure functions and hook logic in isolation
- **Mocking**: Mock Firebase calls; use integration tests for real Firebase behavior
- **Run**: `npm run test` or `npm run test:coverage`

### Component Tests (Storybook)
- **Scope**: All UI components in `src/components/`
- **Approach**: Use `play` functions for interaction testing
- **Required**: Every complex component needs interaction tests
- **Run**: `npm run test-storybook`

### Integration Tests (Jest + Emulators)
- **Scope**: Firestore rules, Cloud Functions, complex queries
- **Environment**: Requires `npm run emulators:start`
- **Run**: `npm run test:integration`

### E2E Tests (Playwright)
- **Scope**: Critical user journeys only
- **Examples**: Voting flow, admin event setup, authentication
- **Run**: `npm run test:e2e`

## What to Test

### Always Test
- Utility functions with logic
- Custom hooks that manage state
- Complex component interactions
- Security rules (via integration tests)
- Critical user flows (via E2E)

### Don't Over-Test
- Simple presentational components (visual review in Storybook is enough)
- Third-party library behavior
- Implementation details that might change

## Writing Good Tests

### Unit Test Example

```typescript
import { describe, it, expect } from 'vitest';
import { calculateScore } from './scoring';

describe('calculateScore', () => {
  it('returns 0 for empty votes', () => {
    expect(calculateScore([])).toBe(0);
  });

  it('sums positive votes correctly', () => {
    expect(calculateScore([1, 2, 3])).toBe(6);
  });

  it('handles negative values', () => {
    expect(calculateScore([1, -1, 2])).toBe(2);
  });
});
```

### Component Test Example (Storybook)

```tsx
export const SubmitFlow: Story = {
  args: {
    onSubmit: fn(),
  },
  play: async ({ canvas, args }) => {
    const input = canvas.getByRole('textbox');
    const button = canvas.getByRole('button', { name: /submit/i });

    await userEvent.type(input, 'Test value');
    await button.click();

    await expect(args.onSubmit).toHaveBeenCalledWith('Test value');
  },
};
```

## Verification Workflow

Before completing any code change:

```bash
# Run full verification (mirrors CI)
npm run verify
```

This runs:
1. ESLint
2. TypeScript check
3. Unit tests
4. Build verification

**All checks must pass before considering work complete.**

## Test Commands Reference

| Command | Purpose |
|---------|---------|
| `npm run verify` | Full verification (lint + type + test + build) |
| `npm run test` | Run unit tests |
| `npm run test:coverage` | Unit tests with coverage report |
| `npm run test-storybook` | Run Storybook interaction tests |
| `npm run test:integration` | Run integration tests (needs emulators) |
| `npm run test:e2e` | Run Playwright E2E tests |

## Debugging Test Failures

1. **Read the error message** - Often contains the fix
2. **Check recent changes** - What did you modify?
3. **Run in isolation** - Focus on the failing test
4. **Check test environment** - Emulators running? Correct node version?
5. **Fix and re-run** - Iterate until green

---

---
trigger: model_decision
description: Standards for building UI components with React, TypeScript, and Storybook.
---

# UI Component Standards

## Component Design Principles

### Single Responsibility
- Each component should do **one thing well**
- If a component handles multiple concerns, split it
- Keep components under ~150 lines; refactor if larger

### Props-Based Design
- Components receive ALL data via props
- Never fetch data inside presentational components
- Use callbacks for user actions (`onClick`, `onSubmit`, etc.)

### TypeScript Requirements

**Always define prop interfaces:**

```tsx
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  onClick?: () => void;
  children: React.ReactNode;
}

export function Button({ 
  variant, 
  size = 'medium', 
  disabled = false,
  onClick,
  children 
}: ButtonProps) {
  // ...
}
```

**Type rules:**
- Export interfaces that other components might use
- Use union types for variants: `'primary' | 'secondary'`
- Provide sensible defaults for optional props
- Avoid `any` - use `unknown` if type is truly unknown

## Storybook Development

### Workflow

1. **Create component and story together** - Don't integrate before testing in Storybook
2. **Cover all states** - Default, loading, error, empty, disabled, hover, focus
3. **Add interaction tests** - Use `play` functions for user interactions
4. **Test accessibility** - Use the a11y addon

### Story Structure

```tsx
import type { Meta, StoryObj } from '@storybook/react';
import { fn, expect } from 'storybook/test';
import { Button } from './Button';

const meta: Meta<typeof Button> = {
  component: Button,
  args: {
    children: 'Click me',
    variant: 'primary',
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Primary: Story = {
  args: { variant: 'primary' },
};

export const Disabled: Story = {
  args: { disabled: true },
};

export const WithInteraction: Story = {
  args: { onClick: fn() },
  play: async ({ canvas, args }) => {
    const button = canvas.getByRole('button');
    await button.click();
    await expect(args.onClick).toHaveBeenCalled();
  },
};
```

### Required Stories

Every component should have stories for:
- ‚úÖ Default/primary state
- ‚úÖ All variants (if applicable)
- ‚úÖ Disabled state (if applicable)
- ‚úÖ Loading state (if applicable)
- ‚úÖ Error state (if applicable)
- ‚úÖ Empty/no data state (if applicable)
- ‚úÖ Interactive behavior (with `play` function)

## Component Patterns

### Container/Presenter Pattern

Separate data fetching from presentation:

```tsx
// Presenter - pure UI, receives everything via props
function UserProfileView({ user, onEdit, isLoading }: UserProfileViewProps) {
  if (isLoading) return <Spinner />;
  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={onEdit}>Edit</button>
    </div>
  );
}

// Container - handles data and logic
function UserProfile({ userId }: { userId: string }) {
  const { user, isLoading } = useUser(userId);
  const handleEdit = () => { /* ... */ };
  
  return <UserProfileView user={user} onEdit={handleEdit} isLoading={isLoading} />;
}
```

### Compound Components

For related components that share state:

```tsx
const Card = ({ children }: { children: React.ReactNode }) => (
  <div className={styles.card}>{children}</div>
);

Card.Header = ({ children }: { children: React.ReactNode }) => (
  <div className={styles.header}>{children}</div>
);

Card.Body = ({ children }: { children: React.ReactNode }) => (
  <div className={styles.body}>{children}</div>
);

// Usage
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
</Card>
```

## Styling

### CSS Modules

- Use `.module.css` files for component styles
- Use camelCase for class names: `styles.buttonPrimary`
- Keep styles scoped to the component

### Naming

```css
/* Button.module.css */
.button { /* base styles */ }
.primary { /* variant */ }
.secondary { /* variant */ }
.small { /* size */ }
.disabled { /* state */ }
```

## Accessibility Checklist

For every interactive component:
- [ ] Uses semantic HTML (`<button>` not `<div onClick>`)
- [ ] Has visible focus states
- [ ] Works with keyboard alone
- [ ] Has appropriate ARIA labels
- [ ] Color contrast meets WCAG AA (4.5:1 for text)
- [ ] Tested with screen reader (or a11y addon)

---

---
trigger: model_decision
description: Zustand state management patterns and best practices.
---

# Zustand Patterns

## Store Structure

**Keep stores focused and small:**

```typescript
interface AuthStore {
  user: User | null;
  isLoading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  isLoading: true,
  signIn: async (email, password) => {
    set({ isLoading: true });
    const user = await authService.signIn(email, password);
    set({ user, isLoading: false });
  },
  signOut: async () => {
    await authService.signOut();
    set({ user: null });
  },
}));
```

## Selectors

**Use selectors to prevent unnecessary re-renders:**

```typescript
// ‚ùå Bad - component re-renders on ANY store change
function UserProfile() {
  const store = useAuthStore();
  return <div>{store.user?.name}</div>;
}

// ‚úÖ Good - only re-renders when user changes
function UserProfile() {
  const user = useAuthStore((state) => state.user);
  return <div>{user?.name}</div>;
}

// ‚úÖ Good - select multiple values
function AuthStatus() {
  const { user, isLoading } = useAuthStore(
    (state) => ({ user: state.user, isLoading: state.isLoading })
  );
}
```

## Async Actions

**Handle loading and error states:**

```typescript
interface EventStore {
  events: Event[];
  isLoading: boolean;
  error: string | null;
  fetchEvents: () => Promise<void>;
}

export const useEventStore = create<EventStore>((set) => ({
  events: [],
  isLoading: false,
  error: null,
  fetchEvents: async () => {
    set({ isLoading: true, error: null });
    try {
      const events = await eventService.getAll();
      set({ events, isLoading: false });
    } catch (error) {
      set({ error: 'Failed to load events', isLoading: false });
    }
  },
}));
```

## Store Organization

```
src/lib/stores/
‚îú‚îÄ‚îÄ useAuthStore.ts      # Authentication state
‚îú‚îÄ‚îÄ useEventStore.ts     # Event data
‚îú‚îÄ‚îÄ useBakerStore.ts     # Baker data
‚îî‚îÄ‚îÄ useUIStore.ts        # UI state (modals, toasts)
```

## When to Use Zustand vs Local State

| Use Case | Solution |
|----------|----------|
| Form input values | `useState` |
| Modal open/closed | `useState` |
| Current user | Zustand |
| Shared data across routes | Zustand |
| Server cache | Zustand or React Query |

## Zustand Checklist

- [ ] Stores are focused (single responsibility)
- [ ] Selectors used to prevent unnecessary re-renders
- [ ] Loading and error states handled in async actions
- [ ] Store actions handle their own errors

---

